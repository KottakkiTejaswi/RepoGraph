/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_pnpm_elkjs_0_10_2_node_modules_elkjs_lib_elk-api_js"],{

/***/ "(app-pages-browser)/../../node_modules/.pnpm/elkjs@0.10.2/node_modules/elkjs/lib/elk-api.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/.pnpm/elkjs@0.10.2/node_modules/elkjs/lib/elk-api.js ***!
  \*******************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=undefined;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=undefined,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/*******************************************************************************\n * Copyright (c) 2017 Kiel University and others.\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *******************************************************************************/\nvar ELK = exports[\"default\"] = /*#__PURE__*/function () {\n  function ELK() {\n    var _this = this;\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$defaultLayoutOpt = _ref.defaultLayoutOptions,\n      defaultLayoutOptions = _ref$defaultLayoutOpt === void 0 ? {} : _ref$defaultLayoutOpt,\n      _ref$algorithms = _ref.algorithms,\n      algorithms = _ref$algorithms === void 0 ? ['layered', 'stress', 'mrtree', 'radial', 'force', 'disco', 'sporeOverlap', 'sporeCompaction', 'rectpacking'] : _ref$algorithms,\n      workerFactory = _ref.workerFactory,\n      workerUrl = _ref.workerUrl;\n    _classCallCheck(this, ELK);\n    this.defaultLayoutOptions = defaultLayoutOptions;\n    this.initialized = false;\n\n    // check valid worker construction possible\n    if (typeof workerUrl === 'undefined' && typeof workerFactory === 'undefined') {\n      throw new Error(\"Cannot construct an ELK without both 'workerUrl' and 'workerFactory'.\");\n    }\n    var factory = workerFactory;\n    if (typeof workerUrl !== 'undefined' && typeof workerFactory === 'undefined') {\n      // use default Web Worker\n      factory = function factory(url) {\n        return new Worker(url);\n      };\n    }\n\n    // create the worker\n    var worker = factory(workerUrl);\n    if (typeof worker.postMessage !== 'function') {\n      throw new TypeError(\"Created worker does not provide\" + \" the required 'postMessage' function.\");\n    }\n\n    // wrap the worker to return promises\n    this.worker = new PromisedWorker(worker);\n\n    // initially register algorithms\n    this.worker.postMessage({\n      cmd: 'register',\n      algorithms: algorithms\n    }).then(function (r) {\n      return _this.initialized = true;\n    })[\"catch\"](console.err);\n  }\n  return _createClass(ELK, [{\n    key: \"layout\",\n    value: function layout(graph) {\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref2$layoutOptions = _ref2.layoutOptions,\n        layoutOptions = _ref2$layoutOptions === void 0 ? this.defaultLayoutOptions : _ref2$layoutOptions,\n        _ref2$logging = _ref2.logging,\n        logging = _ref2$logging === void 0 ? false : _ref2$logging,\n        _ref2$measureExecutio = _ref2.measureExecutionTime,\n        measureExecutionTime = _ref2$measureExecutio === void 0 ? false : _ref2$measureExecutio;\n      if (!graph) {\n        return Promise.reject(new Error(\"Missing mandatory parameter 'graph'.\"));\n      }\n      return this.worker.postMessage({\n        cmd: 'layout',\n        graph: graph,\n        layoutOptions: layoutOptions,\n        options: {\n          logging: logging,\n          measureExecutionTime: measureExecutionTime\n        }\n      });\n    }\n  }, {\n    key: \"knownLayoutAlgorithms\",\n    value: function knownLayoutAlgorithms() {\n      return this.worker.postMessage({\n        cmd: 'algorithms'\n      });\n    }\n  }, {\n    key: \"knownLayoutOptions\",\n    value: function knownLayoutOptions() {\n      return this.worker.postMessage({\n        cmd: 'options'\n      });\n    }\n  }, {\n    key: \"knownLayoutCategories\",\n    value: function knownLayoutCategories() {\n      return this.worker.postMessage({\n        cmd: 'categories'\n      });\n    }\n  }, {\n    key: \"terminateWorker\",\n    value: function terminateWorker() {\n      if (this.worker) this.worker.terminate();\n    }\n  }]);\n}();\nvar PromisedWorker = /*#__PURE__*/function () {\n  function PromisedWorker(worker) {\n    var _this2 = this;\n    _classCallCheck(this, PromisedWorker);\n    if (worker === undefined) {\n      throw new Error(\"Missing mandatory parameter 'worker'.\");\n    }\n    this.resolvers = {};\n    this.worker = worker;\n    this.worker.onmessage = function (answer) {\n      // why is this necessary?\n      setTimeout(function () {\n        _this2.receive(_this2, answer);\n      }, 0);\n    };\n  }\n  return _createClass(PromisedWorker, [{\n    key: \"postMessage\",\n    value: function postMessage(msg) {\n      var id = this.id || 0;\n      this.id = id + 1;\n      msg.id = id;\n      var self = this;\n      return new Promise(function (resolve, reject) {\n        // prepare the resolver\n        self.resolvers[id] = function (err, res) {\n          if (err) {\n            self.convertGwtStyleError(err);\n            reject(err);\n          } else {\n            resolve(res);\n          }\n        };\n        // post the message\n        self.worker.postMessage(msg);\n      });\n    }\n  }, {\n    key: \"receive\",\n    value: function receive(self, answer) {\n      var json = answer.data;\n      var resolver = self.resolvers[json.id];\n      if (resolver) {\n        delete self.resolvers[json.id];\n        if (json.error) {\n          resolver(json.error);\n        } else {\n          resolver(null, json.data);\n        }\n      }\n    }\n  }, {\n    key: \"terminate\",\n    value: function terminate() {\n      if (this.worker) {\n        this.worker.terminate();\n      }\n    }\n  }, {\n    key: \"convertGwtStyleError\",\n    value: function convertGwtStyleError(err) {\n      if (!err) {\n        return;\n      }\n      // Somewhat flatten the way GWT stores nested exception(s)\n      var javaException = err['__java$exception'];\n      if (javaException) {\n        // Note that the property name of the nested exception is different\n        // in the non-minified ('cause') and the minified (not deterministic) version.\n        // Hence, the version below only works for the non-minified version.\n        // However, as the minified stack trace is not of much use anyway, one\n        // should switch the used version for debugging in such a case.\n        if (javaException.cause && javaException.cause.backingJsObject) {\n          err.cause = javaException.cause.backingJsObject;\n          this.convertGwtStyleError(err.cause);\n        }\n        delete err['__java$exception'];\n      }\n    }\n  }]);\n}();\n},{}],2:[function(require,module,exports){\n\"use strict\";\n\n/*******************************************************************************\n * Copyright (c) 2021 Kiel University and others.\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n * \n * SPDX-License-Identifier: EPL-2.0\n *******************************************************************************/\nvar ELK = require('./elk-api.js')[\"default\"];\nObject.defineProperty(module.exports, \"__esModule\", {\n  value: true\n});\nmodule.exports = ELK;\nELK[\"default\"] = ELK;\n},{\"./elk-api.js\":1}]},{},[2])(2)\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZWxranNAMC4xMC4yL25vZGVfbW9kdWxlcy9lbGtqcy9saWIvZWxrLWFwaS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLEdBQUcsSUFBc0QsRUFBRSxtQkFBbUIsS0FBSyxVQUE0TixDQUFDLGFBQWEsMEJBQTBCLG1CQUFtQixrQkFBa0IsZ0JBQWdCLFVBQVUsVUFBVSxNQUFNLFNBQW1DLENBQUMsZ0JBQWdCLE9BQUMsT0FBTyxvQkFBb0IsOENBQThDLGtDQUFrQyxZQUFZLFlBQVksbUNBQW1DLGlCQUFpQixlQUFlLHNCQUFzQixvQkFBb0IsVUFBVSxTQUFtQyxLQUFLLFdBQVcsWUFBWSxTQUFTLFNBQVMsS0FBSztBQUN4ekI7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHNCQUFzQiwyQkFBMkIsb0dBQW9HLG1CQUFtQixpQkFBaUIsc0hBQXNIO0FBQy9TLGlDQUFpQztBQUNqQyxtQ0FBbUMsZ0JBQWdCLGNBQWMsT0FBTyxjQUFjO0FBQ3RGLGlDQUFpQyxxSEFBcUgsY0FBYztBQUNwSyw2QkFBNkIsbUNBQW1DO0FBQ2hFLDhCQUE4Qiw0Q0FBNEMsK0JBQStCLG9CQUFvQixtQ0FBbUMsc0NBQXNDLHVFQUF1RTtBQUM3UTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0QsQ0FBQyxHQUFHO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQyxFQUFFLGlCQUFpQixFQUFFLEdBQUc7QUFDekIsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2Vsa2pzQDAuMTAuMi9ub2RlX21vZHVsZXMvZWxranMvbGliL2Vsay1hcGkuanM/OTZmMiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiJiZ0eXBlb2YgbW9kdWxlIT09XCJ1bmRlZmluZWRcIil7bW9kdWxlLmV4cG9ydHM9ZigpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtdLGYpfWVsc2V7dmFyIGc7aWYodHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCIpe2c9d2luZG93fWVsc2UgaWYodHlwZW9mIGdsb2JhbCE9PVwidW5kZWZpbmVkXCIpe2c9Z2xvYmFsfWVsc2UgaWYodHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiKXtnPXNlbGZ9ZWxzZXtnPXRoaXN9Zy5FTEsgPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikgeyBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHsgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7IHZhciBvID0gclt0XTsgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIF90b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHsgcmV0dXJuIHIgJiYgX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IEtpZWwgVW5pdmVyc2l0eSBhbmQgb3RoZXJzLlxuICpcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGVcbiAqIGF2YWlsYWJsZSB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEVjbGlwc2UgUHVibGljIExpY2Vuc2UgMi4wXG4gKiB3aGljaCBpcyBhdmFpbGFibGUgYXQgaHR0cHM6Ly93d3cuZWNsaXBzZS5vcmcvbGVnYWwvZXBsLTIuMC9cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogRVBMLTIuMFxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG52YXIgRUxLID0gZXhwb3J0c1tcImRlZmF1bHRcIl0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFTEsoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICBfcmVmJGRlZmF1bHRMYXlvdXRPcHQgPSBfcmVmLmRlZmF1bHRMYXlvdXRPcHRpb25zLFxuICAgICAgZGVmYXVsdExheW91dE9wdGlvbnMgPSBfcmVmJGRlZmF1bHRMYXlvdXRPcHQgPT09IHZvaWQgMCA/IHt9IDogX3JlZiRkZWZhdWx0TGF5b3V0T3B0LFxuICAgICAgX3JlZiRhbGdvcml0aG1zID0gX3JlZi5hbGdvcml0aG1zLFxuICAgICAgYWxnb3JpdGhtcyA9IF9yZWYkYWxnb3JpdGhtcyA9PT0gdm9pZCAwID8gWydsYXllcmVkJywgJ3N0cmVzcycsICdtcnRyZWUnLCAncmFkaWFsJywgJ2ZvcmNlJywgJ2Rpc2NvJywgJ3Nwb3JlT3ZlcmxhcCcsICdzcG9yZUNvbXBhY3Rpb24nLCAncmVjdHBhY2tpbmcnXSA6IF9yZWYkYWxnb3JpdGhtcyxcbiAgICAgIHdvcmtlckZhY3RvcnkgPSBfcmVmLndvcmtlckZhY3RvcnksXG4gICAgICB3b3JrZXJVcmwgPSBfcmVmLndvcmtlclVybDtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRUxLKTtcbiAgICB0aGlzLmRlZmF1bHRMYXlvdXRPcHRpb25zID0gZGVmYXVsdExheW91dE9wdGlvbnM7XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuXG4gICAgLy8gY2hlY2sgdmFsaWQgd29ya2VyIGNvbnN0cnVjdGlvbiBwb3NzaWJsZVxuICAgIGlmICh0eXBlb2Ygd29ya2VyVXJsID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd29ya2VyRmFjdG9yeSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb25zdHJ1Y3QgYW4gRUxLIHdpdGhvdXQgYm90aCAnd29ya2VyVXJsJyBhbmQgJ3dvcmtlckZhY3RvcnknLlwiKTtcbiAgICB9XG4gICAgdmFyIGZhY3RvcnkgPSB3b3JrZXJGYWN0b3J5O1xuICAgIGlmICh0eXBlb2Ygd29ya2VyVXJsICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd29ya2VyRmFjdG9yeSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIHVzZSBkZWZhdWx0IFdlYiBXb3JrZXJcbiAgICAgIGZhY3RvcnkgPSBmdW5jdGlvbiBmYWN0b3J5KHVybCkge1xuICAgICAgICByZXR1cm4gbmV3IFdvcmtlcih1cmwpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgdGhlIHdvcmtlclxuICAgIHZhciB3b3JrZXIgPSBmYWN0b3J5KHdvcmtlclVybCk7XG4gICAgaWYgKHR5cGVvZiB3b3JrZXIucG9zdE1lc3NhZ2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDcmVhdGVkIHdvcmtlciBkb2VzIG5vdCBwcm92aWRlXCIgKyBcIiB0aGUgcmVxdWlyZWQgJ3Bvc3RNZXNzYWdlJyBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgLy8gd3JhcCB0aGUgd29ya2VyIHRvIHJldHVybiBwcm9taXNlc1xuICAgIHRoaXMud29ya2VyID0gbmV3IFByb21pc2VkV29ya2VyKHdvcmtlcik7XG5cbiAgICAvLyBpbml0aWFsbHkgcmVnaXN0ZXIgYWxnb3JpdGhtc1xuICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgIGNtZDogJ3JlZ2lzdGVyJyxcbiAgICAgIGFsZ29yaXRobXM6IGFsZ29yaXRobXNcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChyKSB7XG4gICAgICByZXR1cm4gX3RoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH0pW1wiY2F0Y2hcIl0oY29uc29sZS5lcnIpO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRUxLLCBbe1xuICAgIGtleTogXCJsYXlvdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGF5b3V0KGdyYXBoKSB7XG4gICAgICB2YXIgX3JlZjIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgICAgICBfcmVmMiRsYXlvdXRPcHRpb25zID0gX3JlZjIubGF5b3V0T3B0aW9ucyxcbiAgICAgICAgbGF5b3V0T3B0aW9ucyA9IF9yZWYyJGxheW91dE9wdGlvbnMgPT09IHZvaWQgMCA/IHRoaXMuZGVmYXVsdExheW91dE9wdGlvbnMgOiBfcmVmMiRsYXlvdXRPcHRpb25zLFxuICAgICAgICBfcmVmMiRsb2dnaW5nID0gX3JlZjIubG9nZ2luZyxcbiAgICAgICAgbG9nZ2luZyA9IF9yZWYyJGxvZ2dpbmcgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjIkbG9nZ2luZyxcbiAgICAgICAgX3JlZjIkbWVhc3VyZUV4ZWN1dGlvID0gX3JlZjIubWVhc3VyZUV4ZWN1dGlvblRpbWUsXG4gICAgICAgIG1lYXN1cmVFeGVjdXRpb25UaW1lID0gX3JlZjIkbWVhc3VyZUV4ZWN1dGlvID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYyJG1lYXN1cmVFeGVjdXRpbztcbiAgICAgIGlmICghZ3JhcGgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIk1pc3NpbmcgbWFuZGF0b3J5IHBhcmFtZXRlciAnZ3JhcGgnLlwiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBjbWQ6ICdsYXlvdXQnLFxuICAgICAgICBncmFwaDogZ3JhcGgsXG4gICAgICAgIGxheW91dE9wdGlvbnM6IGxheW91dE9wdGlvbnMsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBsb2dnaW5nOiBsb2dnaW5nLFxuICAgICAgICAgIG1lYXN1cmVFeGVjdXRpb25UaW1lOiBtZWFzdXJlRXhlY3V0aW9uVGltZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwia25vd25MYXlvdXRBbGdvcml0aG1zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtub3duTGF5b3V0QWxnb3JpdGhtcygpIHtcbiAgICAgIHJldHVybiB0aGlzLndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGNtZDogJ2FsZ29yaXRobXMnXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwia25vd25MYXlvdXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtub3duTGF5b3V0T3B0aW9ucygpIHtcbiAgICAgIHJldHVybiB0aGlzLndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGNtZDogJ29wdGlvbnMnXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwia25vd25MYXlvdXRDYXRlZ29yaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtub3duTGF5b3V0Q2F0ZWdvcmllcygpIHtcbiAgICAgIHJldHVybiB0aGlzLndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGNtZDogJ2NhdGVnb3JpZXMnXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGVybWluYXRlV29ya2VyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRlcm1pbmF0ZVdvcmtlcigpIHtcbiAgICAgIGlmICh0aGlzLndvcmtlcikgdGhpcy53b3JrZXIudGVybWluYXRlKCk7XG4gICAgfVxuICB9XSk7XG59KCk7XG52YXIgUHJvbWlzZWRXb3JrZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQcm9taXNlZFdvcmtlcih3b3JrZXIpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHJvbWlzZWRXb3JrZXIpO1xuICAgIGlmICh3b3JrZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBtYW5kYXRvcnkgcGFyYW1ldGVyICd3b3JrZXInLlwiKTtcbiAgICB9XG4gICAgdGhpcy5yZXNvbHZlcnMgPSB7fTtcbiAgICB0aGlzLndvcmtlciA9IHdvcmtlcjtcbiAgICB0aGlzLndvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoYW5zd2VyKSB7XG4gICAgICAvLyB3aHkgaXMgdGhpcyBuZWNlc3Nhcnk/XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnJlY2VpdmUoX3RoaXMyLCBhbnN3ZXIpO1xuICAgICAgfSwgMCk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFByb21pc2VkV29ya2VyLCBbe1xuICAgIGtleTogXCJwb3N0TWVzc2FnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3N0TWVzc2FnZShtc2cpIHtcbiAgICAgIHZhciBpZCA9IHRoaXMuaWQgfHwgMDtcbiAgICAgIHRoaXMuaWQgPSBpZCArIDE7XG4gICAgICBtc2cuaWQgPSBpZDtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIC8vIHByZXBhcmUgdGhlIHJlc29sdmVyXG4gICAgICAgIHNlbGYucmVzb2x2ZXJzW2lkXSA9IGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHNlbGYuY29udmVydEd3dFN0eWxlRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHJlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBwb3N0IHRoZSBtZXNzYWdlXG4gICAgICAgIHNlbGYud29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVjZWl2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWNlaXZlKHNlbGYsIGFuc3dlcikge1xuICAgICAgdmFyIGpzb24gPSBhbnN3ZXIuZGF0YTtcbiAgICAgIHZhciByZXNvbHZlciA9IHNlbGYucmVzb2x2ZXJzW2pzb24uaWRdO1xuICAgICAgaWYgKHJlc29sdmVyKSB7XG4gICAgICAgIGRlbGV0ZSBzZWxmLnJlc29sdmVyc1tqc29uLmlkXTtcbiAgICAgICAgaWYgKGpzb24uZXJyb3IpIHtcbiAgICAgICAgICByZXNvbHZlcihqc29uLmVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlcihudWxsLCBqc29uLmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRlcm1pbmF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXJtaW5hdGUoKSB7XG4gICAgICBpZiAodGhpcy53b3JrZXIpIHtcbiAgICAgICAgdGhpcy53b3JrZXIudGVybWluYXRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbnZlcnRHd3RTdHlsZUVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnZlcnRHd3RTdHlsZUVycm9yKGVycikge1xuICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gU29tZXdoYXQgZmxhdHRlbiB0aGUgd2F5IEdXVCBzdG9yZXMgbmVzdGVkIGV4Y2VwdGlvbihzKVxuICAgICAgdmFyIGphdmFFeGNlcHRpb24gPSBlcnJbJ19famF2YSRleGNlcHRpb24nXTtcbiAgICAgIGlmIChqYXZhRXhjZXB0aW9uKSB7XG4gICAgICAgIC8vIE5vdGUgdGhhdCB0aGUgcHJvcGVydHkgbmFtZSBvZiB0aGUgbmVzdGVkIGV4Y2VwdGlvbiBpcyBkaWZmZXJlbnRcbiAgICAgICAgLy8gaW4gdGhlIG5vbi1taW5pZmllZCAoJ2NhdXNlJykgYW5kIHRoZSBtaW5pZmllZCAobm90IGRldGVybWluaXN0aWMpIHZlcnNpb24uXG4gICAgICAgIC8vIEhlbmNlLCB0aGUgdmVyc2lvbiBiZWxvdyBvbmx5IHdvcmtzIGZvciB0aGUgbm9uLW1pbmlmaWVkIHZlcnNpb24uXG4gICAgICAgIC8vIEhvd2V2ZXIsIGFzIHRoZSBtaW5pZmllZCBzdGFjayB0cmFjZSBpcyBub3Qgb2YgbXVjaCB1c2UgYW55d2F5LCBvbmVcbiAgICAgICAgLy8gc2hvdWxkIHN3aXRjaCB0aGUgdXNlZCB2ZXJzaW9uIGZvciBkZWJ1Z2dpbmcgaW4gc3VjaCBhIGNhc2UuXG4gICAgICAgIGlmIChqYXZhRXhjZXB0aW9uLmNhdXNlICYmIGphdmFFeGNlcHRpb24uY2F1c2UuYmFja2luZ0pzT2JqZWN0KSB7XG4gICAgICAgICAgZXJyLmNhdXNlID0gamF2YUV4Y2VwdGlvbi5jYXVzZS5iYWNraW5nSnNPYmplY3Q7XG4gICAgICAgICAgdGhpcy5jb252ZXJ0R3d0U3R5bGVFcnJvcihlcnIuY2F1c2UpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBlcnJbJ19famF2YSRleGNlcHRpb24nXTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbn0oKTtcbn0se31dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjEgS2llbCBVbml2ZXJzaXR5IGFuZCBvdGhlcnMuXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBFY2xpcHNlIFB1YmxpYyBMaWNlbnNlIDIuMCB3aGljaCBpcyBhdmFpbGFibGUgYXRcbiAqIGh0dHA6Ly93d3cuZWNsaXBzZS5vcmcvbGVnYWwvZXBsLTIuMC5cbiAqIFxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEVQTC0yLjBcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xudmFyIEVMSyA9IHJlcXVpcmUoJy4vZWxrLWFwaS5qcycpW1wiZGVmYXVsdFwiXTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBFTEs7XG5FTEtbXCJkZWZhdWx0XCJdID0gRUxLO1xufSx7XCIuL2Vsay1hcGkuanNcIjoxfV19LHt9LFsyXSkoMilcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/elkjs@0.10.2/node_modules/elkjs/lib/elk-api.js\n"));

/***/ })

}]);