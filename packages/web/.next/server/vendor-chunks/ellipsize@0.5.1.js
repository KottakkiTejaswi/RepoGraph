"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ellipsize@0.5.1";
exports.ids = ["vendor-chunks/ellipsize@0.5.1"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/ellipsize@0.5.1/node_modules/ellipsize/src/index.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ellipsize@0.5.1/node_modules/ellipsize/src/index.js ***!
  \************************************************************************************/
/***/ ((module) => {

eval("\n\nvar defaults = {\n    ellipse: \"…\",\n    chars: [\" \", \"-\"],\n    max: 140,\n    truncate: true,\n};\n\n/**\n * \"mac-style\" or \"harmonica\" ellipsize.\n * Ellipsizes a string in the middle instead of the end.\n *\n * Examples:\n *\n *      These are a few of my favourite things\n *      These are … my faourite things\n *      These are … faourite things\n *      hese … things\n *\n * @param {string} str\n * @param {Number} max\n * @param {string} ellipse\n * @param {string[]} chars\n * @returns {string} ellipsized\n */\n\nfunction ellipsizeMiddle(str, max, ellipse, chars) {\n    if (str <= max) return str;\n    if (max < 2) return str.slice(0, max - ellipse.length) + ellipse;\n\n    var maxLen = max - ellipse.length;\n    var middle = Math.floor(maxLen / 2);\n\n    var left = middle;\n    var right = str.length - middle;\n\n    for (var i = 0; i < middle; i++) {\n        var charLeft = str.charAt(i);\n        var posRight = str.length - i;\n\n        var charRight = str.charAt(posRight);\n\n        if (chars.indexOf(charLeft) !== -1) left = i;\n        if (chars.indexOf(charRight) !== -1) right = posRight;\n    }\n\n    return str.slice(0, left) + ellipse + str.slice(right);\n}\n\n/**\n *\n * @param {string} str\n * @param {number} max\n * @param {string} ellipse\n * @param {string[]} chars\n * @param {boolean} truncate\n * @returns\n */\nfunction ellipsize(str, max, ellipse, chars, truncate) {\n    if (str.length <= max) return str;\n\n    var maxLen = max - ellipse.length;\n    var end = maxLen;\n\n    for (var i = 0; i <= maxLen; i++) {\n        var char = str.charAt(i);\n        if (chars.indexOf(char) !== -1) end = i;\n    }\n\n    // no breakpoint found, but truncate\n    // was not allowed.\n    if (!truncate && end == maxLen) return \"\";\n\n    return str.slice(0, end) + ellipse;\n}\n\n/**\n * Ellipsize a string. Produces a string that is max lenght,\n * including the ellipse character.\n *\n * @param {string} str - String to ellipsize\n * @param {number} max - Max length including ellipsis\n * @param {Record<string, any>} [opts] - See additional options\n * @returns {string} ellipsized string\n */\nmodule.exports = function (str, max, opts) {\n    if (typeof str !== \"string\" || str.length === 0) return \"\";\n    if (max === 0) return \"\";\n\n    opts = opts || {};\n\n    for (var key in defaults) {\n        if (opts[key] === null || typeof opts[key] === \"undefined\") {\n            opts[key] = defaults[key];\n        }\n    }\n\n    opts.max = max || opts.max;\n\n    if (opts.truncate == \"middle\")\n        return ellipsizeMiddle(str, opts.max, opts.ellipse, opts.chars);\n\n    return ellipsize(str, opts.max, opts.ellipse, opts.chars, opts.truncate);\n};\n\nmodule.exports.ellipsizeMiddle = ellipsizeMiddle;\nmodule.exports.ellipsize = ellipsize;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2VsbGlwc2l6ZUAwLjUuMS9ub2RlX21vZHVsZXMvZWxsaXBzaXplL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixhQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLHFCQUFxQjtBQUNoQyxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCLHdCQUF3QiIsInNvdXJjZXMiOlsid2VicGFjazovL0ByZXBvZ3JhcGgvd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9lbGxpcHNpemVAMC41LjEvbm9kZV9tb2R1bGVzL2VsbGlwc2l6ZS9zcmMvaW5kZXguanM/MGNjZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIGRlZmF1bHRzID0ge1xuICAgIGVsbGlwc2U6IFwi4oCmXCIsXG4gICAgY2hhcnM6IFtcIiBcIiwgXCItXCJdLFxuICAgIG1heDogMTQwLFxuICAgIHRydW5jYXRlOiB0cnVlLFxufTtcblxuLyoqXG4gKiBcIm1hYy1zdHlsZVwiIG9yIFwiaGFybW9uaWNhXCIgZWxsaXBzaXplLlxuICogRWxsaXBzaXplcyBhIHN0cmluZyBpbiB0aGUgbWlkZGxlIGluc3RlYWQgb2YgdGhlIGVuZC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIFRoZXNlIGFyZSBhIGZldyBvZiBteSBmYXZvdXJpdGUgdGhpbmdzXG4gKiAgICAgIFRoZXNlIGFyZSDigKYgbXkgZmFvdXJpdGUgdGhpbmdzXG4gKiAgICAgIFRoZXNlIGFyZSDigKYgZmFvdXJpdGUgdGhpbmdzXG4gKiAgICAgIGhlc2Ug4oCmIHRoaW5nc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbGxpcHNlXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBjaGFyc1xuICogQHJldHVybnMge3N0cmluZ30gZWxsaXBzaXplZFxuICovXG5cbmZ1bmN0aW9uIGVsbGlwc2l6ZU1pZGRsZShzdHIsIG1heCwgZWxsaXBzZSwgY2hhcnMpIHtcbiAgICBpZiAoc3RyIDw9IG1heCkgcmV0dXJuIHN0cjtcbiAgICBpZiAobWF4IDwgMikgcmV0dXJuIHN0ci5zbGljZSgwLCBtYXggLSBlbGxpcHNlLmxlbmd0aCkgKyBlbGxpcHNlO1xuXG4gICAgdmFyIG1heExlbiA9IG1heCAtIGVsbGlwc2UubGVuZ3RoO1xuICAgIHZhciBtaWRkbGUgPSBNYXRoLmZsb29yKG1heExlbiAvIDIpO1xuXG4gICAgdmFyIGxlZnQgPSBtaWRkbGU7XG4gICAgdmFyIHJpZ2h0ID0gc3RyLmxlbmd0aCAtIG1pZGRsZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWlkZGxlOyBpKyspIHtcbiAgICAgICAgdmFyIGNoYXJMZWZ0ID0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgdmFyIHBvc1JpZ2h0ID0gc3RyLmxlbmd0aCAtIGk7XG5cbiAgICAgICAgdmFyIGNoYXJSaWdodCA9IHN0ci5jaGFyQXQocG9zUmlnaHQpO1xuXG4gICAgICAgIGlmIChjaGFycy5pbmRleE9mKGNoYXJMZWZ0KSAhPT0gLTEpIGxlZnQgPSBpO1xuICAgICAgICBpZiAoY2hhcnMuaW5kZXhPZihjaGFyUmlnaHQpICE9PSAtMSkgcmlnaHQgPSBwb3NSaWdodDtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyLnNsaWNlKDAsIGxlZnQpICsgZWxsaXBzZSArIHN0ci5zbGljZShyaWdodCk7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbGxpcHNlXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBjaGFyc1xuICogQHBhcmFtIHtib29sZWFufSB0cnVuY2F0ZVxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gZWxsaXBzaXplKHN0ciwgbWF4LCBlbGxpcHNlLCBjaGFycywgdHJ1bmNhdGUpIHtcbiAgICBpZiAoc3RyLmxlbmd0aCA8PSBtYXgpIHJldHVybiBzdHI7XG5cbiAgICB2YXIgbWF4TGVuID0gbWF4IC0gZWxsaXBzZS5sZW5ndGg7XG4gICAgdmFyIGVuZCA9IG1heExlbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IG1heExlbjsgaSsrKSB7XG4gICAgICAgIHZhciBjaGFyID0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgaWYgKGNoYXJzLmluZGV4T2YoY2hhcikgIT09IC0xKSBlbmQgPSBpO1xuICAgIH1cblxuICAgIC8vIG5vIGJyZWFrcG9pbnQgZm91bmQsIGJ1dCB0cnVuY2F0ZVxuICAgIC8vIHdhcyBub3QgYWxsb3dlZC5cbiAgICBpZiAoIXRydW5jYXRlICYmIGVuZCA9PSBtYXhMZW4pIHJldHVybiBcIlwiO1xuXG4gICAgcmV0dXJuIHN0ci5zbGljZSgwLCBlbmQpICsgZWxsaXBzZTtcbn1cblxuLyoqXG4gKiBFbGxpcHNpemUgYSBzdHJpbmcuIFByb2R1Y2VzIGEgc3RyaW5nIHRoYXQgaXMgbWF4IGxlbmdodCxcbiAqIGluY2x1ZGluZyB0aGUgZWxsaXBzZSBjaGFyYWN0ZXIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIFN0cmluZyB0byBlbGxpcHNpemVcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSBNYXggbGVuZ3RoIGluY2x1ZGluZyBlbGxpcHNpc1xuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBbb3B0c10gLSBTZWUgYWRkaXRpb25hbCBvcHRpb25zXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBlbGxpcHNpemVkIHN0cmluZ1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIsIG1heCwgb3B0cykge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSBcInN0cmluZ1wiIHx8IHN0ci5sZW5ndGggPT09IDApIHJldHVybiBcIlwiO1xuICAgIGlmIChtYXggPT09IDApIHJldHVybiBcIlwiO1xuXG4gICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gZGVmYXVsdHMpIHtcbiAgICAgICAgaWYgKG9wdHNba2V5XSA9PT0gbnVsbCB8fCB0eXBlb2Ygb3B0c1trZXldID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBvcHRzW2tleV0gPSBkZWZhdWx0c1trZXldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3B0cy5tYXggPSBtYXggfHwgb3B0cy5tYXg7XG5cbiAgICBpZiAob3B0cy50cnVuY2F0ZSA9PSBcIm1pZGRsZVwiKVxuICAgICAgICByZXR1cm4gZWxsaXBzaXplTWlkZGxlKHN0ciwgb3B0cy5tYXgsIG9wdHMuZWxsaXBzZSwgb3B0cy5jaGFycyk7XG5cbiAgICByZXR1cm4gZWxsaXBzaXplKHN0ciwgb3B0cy5tYXgsIG9wdHMuZWxsaXBzZSwgb3B0cy5jaGFycywgb3B0cy50cnVuY2F0ZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5lbGxpcHNpemVNaWRkbGUgPSBlbGxpcHNpemVNaWRkbGU7XG5tb2R1bGUuZXhwb3J0cy5lbGxpcHNpemUgPSBlbGxpcHNpemU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/ellipsize@0.5.1/node_modules/ellipsize/src/index.js\n");

/***/ })

};
;