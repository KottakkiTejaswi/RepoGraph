"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/kld-polynomial@0.3.0";
exports.ids = ["vendor-chunks/kld-polynomial@0.3.0"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/kld-polynomial@0.3.0/node_modules/kld-polynomial/index.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/.pnpm/kld-polynomial@0.3.0/node_modules/kld-polynomial/index.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Polynomial: () => (/* reexport safe */ _lib_Polynomial_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   SqrtPolynomial: () => (/* reexport safe */ _lib_SqrtPolynomial_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _lib_Polynomial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/Polynomial.js */ \"(ssr)/../../node_modules/.pnpm/kld-polynomial@0.3.0/node_modules/kld-polynomial/lib/Polynomial.js\");\n/* harmony import */ var _lib_SqrtPolynomial_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/SqrtPolynomial.js */ \"(ssr)/../../node_modules/.pnpm/kld-polynomial@0.3.0/node_modules/kld-polynomial/lib/SqrtPolynomial.js\");\n/**\n *  @module kld-polynomial\n */\n\n// expose classes\n\n/**\n *  @namespace Polynomial\n *  @implements {module:Polynomial~Polynomial}\n */\n\n\n/**\n *  @namespace SqrtPolynomial\n *  @implements {module:SqrtPolynomial~SqrtPolynomial}\n */\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2tsZC1wb2x5bm9taWFsQDAuMy4wL25vZGVfbW9kdWxlcy9rbGQtcG9seW5vbWlhbC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDMEQ7O0FBRTFEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDa0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcmVwb2dyYXBoL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0va2xkLXBvbHlub21pYWxAMC4zLjAvbm9kZV9tb2R1bGVzL2tsZC1wb2x5bm9taWFsL2luZGV4LmpzPzExNDMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAgQG1vZHVsZSBrbGQtcG9seW5vbWlhbFxuICovXG5cbi8vIGV4cG9zZSBjbGFzc2VzXG5cbi8qKlxuICogIEBuYW1lc3BhY2UgUG9seW5vbWlhbFxuICogIEBpbXBsZW1lbnRzIHttb2R1bGU6UG9seW5vbWlhbH5Qb2x5bm9taWFsfVxuICovXG5leHBvcnQge2RlZmF1bHQgYXMgUG9seW5vbWlhbH0gZnJvbSBcIi4vbGliL1BvbHlub21pYWwuanNcIjtcblxuLyoqXG4gKiAgQG5hbWVzcGFjZSBTcXJ0UG9seW5vbWlhbFxuICogIEBpbXBsZW1lbnRzIHttb2R1bGU6U3FydFBvbHlub21pYWx+U3FydFBvbHlub21pYWx9XG4gKi9cbmV4cG9ydCB7ZGVmYXVsdCBhcyBTcXJ0UG9seW5vbWlhbH0gZnJvbSBcIi4vbGliL1NxcnRQb2x5bm9taWFsLmpzXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/kld-polynomial@0.3.0/node_modules/kld-polynomial/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/kld-polynomial@0.3.0/node_modules/kld-polynomial/lib/Polynomial.js":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/kld-polynomial@0.3.0/node_modules/kld-polynomial/lib/Polynomial.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* eslint-disable camelcase */\n/**\n *  Polynomial.js\n *\n *  @module Polynomial\n *  @copyright 2002-2019 Kevin Lindsey<br>\n *  -<br>\n *  Contribution {@link http://github.com/Quazistax/kld-polynomial}<br>\n *  copyright 2015 Robert Benko (Quazistax) <quazistax@gmail.com><br>\n *  MIT license\n */\n\n/**\n *  Sign of a number (+1, -1, +0, -0).\n *\n *  @param {number} x\n *  @returns {number}\n */\nfunction sign(x) {\n    // eslint-disable-next-line no-self-compare\n    return typeof x === \"number\" ? x ? x < 0 ? -1 : 1 : x === x ? x : NaN : NaN;\n}\n\n/**\n *  Polynomial\n *\n *  @memberof module:kld-polynomial\n */\nclass Polynomial {\n    /**\n     *  Polynomial\n     *\n     *  @param {Array<number>} coefs\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    constructor(...coefs) {\n        this.coefs = [];\n\n        for (let i = coefs.length - 1; i >= 0; i--) {\n            this.coefs.push(coefs[i]);\n        }\n\n        this._variable = \"t\";\n        this._s = 0;\n    }\n\n    /**\n     *  Based on polint in \"Numerical Recipes in C, 2nd Edition\", pages 109-110\n     *\n     *  @param {Array<number>} xs\n     *  @param {Array<number>} ys\n     *  @param {number} n\n     *  @param {number} offset\n     *  @param {number} x\n     *\n     *  @returns {{y: number, dy: number}}\n     */\n    static interpolate(xs, ys, n, offset, x) {\n        if (xs.constructor !== Array || ys.constructor !== Array) {\n            throw new TypeError(\"xs and ys must be arrays\");\n        }\n        if (isNaN(n) || isNaN(offset) || isNaN(x)) {\n            throw new TypeError(\"n, offset, and x must be numbers\");\n        }\n\n        let i, y;\n        let dy = 0;\n        const c = new Array(n);\n        const d = new Array(n);\n        let ns = 0;\n\n        let diff = Math.abs(x - xs[offset]);\n\n        for (i = 0; i < n; i++) {\n            const dift = Math.abs(x - xs[offset + i]);\n\n            if (dift < diff) {\n                ns = i;\n                diff = dift;\n            }\n            c[i] = d[i] = ys[offset + i];\n        }\n\n        y = ys[offset + ns];\n        ns--;\n\n        for (let m = 1; m < n; m++) {\n            for (i = 0; i < n - m; i++) {\n                const ho = xs[offset + i] - x;\n                const hp = xs[offset + i + m] - x;\n                const w = c[i + 1] - d[i];\n                let den = ho - hp;\n\n                if (den === 0.0) {\n                    throw new RangeError(\"Unable to interpolate polynomial. Two numbers in n were identical (to within roundoff)\");\n                }\n\n                den = w / den;\n                d[i] = hp * den;\n                c[i] = ho * den;\n            }\n\n            dy = (2 * (ns + 1) < (n - m)) ? c[ns + 1] : d[ns--];\n            y += dy;\n        }\n\n        return {y, dy};\n    }\n\n    /**\n     *  Newton's (Newton-Raphson) method for finding Real roots on univariate function. <br/>\n     *  When using bounds, algorithm falls back to secant if newton goes out of range.\n     *  Bisection is fallback for secant when determined secant is not efficient enough.\n     *  @see {@link http://en.wikipedia.org/wiki/Newton%27s_method}\n     *  @see {@link http://en.wikipedia.org/wiki/Secant_method}\n     *  @see {@link http://en.wikipedia.org/wiki/Bisection_method}\n     *\n     *  @param {number} x0 - Initial root guess\n     *  @param {Function} f - Function which root we are trying to find\n     *  @param {Function} df - Derivative of function f\n     *  @param {number} max_iterations - Maximum number of algorithm iterations\n     *  @param {number} [min] - Left bound value\n     *  @param {number} [max] - Right bound value\n     *  @returns {number} root\n     */\n    static newtonSecantBisection(x0, f, df, max_iterations, min, max) {\n        let x, prev_dfx = 0, dfx, prev_x_ef_correction = 0, x_correction, x_new;\n        let y, y_atmin, y_atmax;\n\n        x = x0;\n\n        const ACCURACY = 14;\n        const min_correction_factor = Math.pow(10, -ACCURACY);\n        const isBounded = (typeof min === \"number\" && typeof max === \"number\");\n\n        if (isBounded) {\n            if (min > max) {\n                throw new RangeError(\"Min must be greater than max\");\n            }\n\n            y_atmin = f(min);\n            y_atmax = f(max);\n\n            if (sign(y_atmin) === sign(y_atmax)) {\n                throw new RangeError(\"Y values of bounds must be of opposite sign\");\n            }\n        }\n\n        const isEnoughCorrection = function() {\n            // stop if correction is too small or if correction is in simple loop\n            return (Math.abs(x_correction) <= min_correction_factor * Math.abs(x)) ||\n                (prev_x_ef_correction === (x - x_correction) - x);\n        };\n\n        for (let i = 0; i < max_iterations; i++) {\n            dfx = df(x);\n\n            if (dfx === 0) {\n                if (prev_dfx === 0) {\n                    // error\n                    throw new RangeError(\"df(x) is zero\");\n                }\n                else {\n                    // use previous derivation value\n                    dfx = prev_dfx;\n                }\n                // or move x a little?\n                // dfx = df(x != 0 ? x + x * 1e-15 : 1e-15);\n            }\n\n            prev_dfx = dfx;\n            y = f(x);\n            x_correction = y / dfx;\n            x_new = x - x_correction;\n\n            if (isEnoughCorrection()) {\n                break;\n            }\n\n            if (isBounded) {\n                if (sign(y) === sign(y_atmax)) {\n                    max = x;\n                    y_atmax = y;\n                }\n                else if (sign(y) === sign(y_atmin)) {\n                    min = x;\n                    y_atmin = y;\n                }\n                else {\n                    x = x_new;\n                    break;\n                }\n\n                if ((x_new < min) || (x_new > max)) {\n                    if (sign(y_atmin) === sign(y_atmax)) {\n                        break;\n                    }\n\n                    const RATIO_LIMIT = 50;\n                    const AIMED_BISECT_OFFSET = 0.25; // [0, 0.5)\n                    const dy = y_atmax - y_atmin;\n                    const dx = max - min;\n\n                    if (dy === 0) {\n                        x_correction = x - (min + dx * 0.5);\n                    }\n                    else if (Math.abs(dy / Math.min(y_atmin, y_atmax)) > RATIO_LIMIT) {\n                        x_correction = x - (min + dx * (0.5 + (Math.abs(y_atmin) < Math.abs(y_atmax) ? -AIMED_BISECT_OFFSET : AIMED_BISECT_OFFSET)));\n                    }\n                    else {\n                        x_correction = x - (min - y_atmin / dy * dx);\n                    }\n                    x_new = x - x_correction;\n\n                    if (isEnoughCorrection()) {\n                        break;\n                    }\n                }\n            }\n\n            prev_x_ef_correction = x - x_new;\n            x = x_new;\n        }\n\n        return x;\n    }\n\n    /**\n     *  Clones this polynomial and return the clone.\n     *\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    clone() {\n        const poly = new Polynomial();\n\n        poly.coefs = this.coefs.slice();\n\n        return poly;\n    }\n\n    /**\n     *  eval\n     *\n     *  @param {number} x\n     */\n    eval(x) {\n        if (isNaN(x)) {\n            throw new TypeError(`Parameter must be a number. Found '${x}'`);\n        }\n\n        let result = 0;\n\n        for (let i = this.coefs.length - 1; i >= 0; i--) {\n            result = result * x + this.coefs[i];\n        }\n\n        return result;\n    }\n\n    /**\n     *  add\n     *\n     *  @param {module:kld-polynomial.Polynomial} that\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    add(that) {\n        const result = new Polynomial();\n        const d1 = this.getDegree();\n        const d2 = that.getDegree();\n        const dmax = Math.max(d1, d2);\n\n        for (let i = 0; i <= dmax; i++) {\n            const v1 = (i <= d1) ? this.coefs[i] : 0;\n            const v2 = (i <= d2) ? that.coefs[i] : 0;\n\n            result.coefs[i] = v1 + v2;\n        }\n\n        return result;\n    }\n\n    /**\n     *  multiply\n     *\n     *  @param {module:kld-polynomial.Polynomial} that\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    multiply(that) {\n        const result = new Polynomial();\n\n        for (let i = 0; i <= this.getDegree() + that.getDegree(); i++) {\n            result.coefs.push(0);\n        }\n\n        for (let i = 0; i <= this.getDegree(); i++) {\n            for (let j = 0; j <= that.getDegree(); j++) {\n                result.coefs[i + j] += this.coefs[i] * that.coefs[j];\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     *  divideEqualsScalar\n     *\n     *  @deprecated To be replaced by divideScalar\n     *  @param {number} scalar\n     */\n    divideEqualsScalar(scalar) {\n        for (let i = 0; i < this.coefs.length; i++) {\n            this.coefs[i] /= scalar;\n        }\n    }\n\n    /**\n     *  simplifyEquals\n     *\n     *  @deprecated To be replaced by simplify\n     *  @param {number} TOLERANCE\n     */\n    simplifyEquals(TOLERANCE = 1e-12) {\n        for (let i = this.getDegree(); i >= 0; i--) {\n            if (Math.abs(this.coefs[i]) <= TOLERANCE) {\n                this.coefs.pop();\n            }\n            else {\n                break;\n            }\n        }\n    }\n\n    /**\n     *  Sets small coefficients to zero.\n     *\n     *  @deprecated To be replaced by removeZeros\n     *  @param {number} TOLERANCE\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    removeZerosEquals(TOLERANCE = 1e-15) {\n        const c = this.coefs;\n        const err = 10 * TOLERANCE * Math.abs(\n            c.reduce((pv, cv) => {\n                return Math.abs(cv) > Math.abs(pv) ? cv : pv;\n            })\n        );\n\n        for (let i = 0; i < c.length - 1; i++) {\n            if (Math.abs(c[i]) < err) {\n                c[i] = 0;\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     *  Scales polynomial so that leading coefficient becomes 1.\n     *\n     *  @deprecated To be replaced by getMonic\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    monicEquals() {\n        const c = this.coefs;\n\n        if (c[c.length - 1] !== 1) {\n            this.divideEqualsScalar(c[c.length - 1]);\n        }\n\n        return this;\n    }\n\n    /**\n     *  toString\n     *\n     *  @returns {string}\n     */\n    toString() {\n        const coefs = [];\n        const signs = [];\n\n        for (let i = this.coefs.length - 1; i >= 0; i--) {\n            let value = Math.round(this.coefs[i] * 1000) / 1000;\n\n            if (value !== 0) {\n                const signString = (value < 0) ? \" - \" : \" + \";\n\n                value = Math.abs(value);\n\n                if (i > 0) {\n                    if (value === 1) {\n                        value = this._variable;\n                    }\n                    else {\n                        value += this._variable;\n                    }\n                }\n\n                if (i > 1) {\n                    value += \"^\" + i;\n                }\n\n                signs.push(signString);\n                coefs.push(value);\n            }\n        }\n\n        signs[0] = (signs[0] === \" + \") ? \"\" : \"-\";\n\n        let result = \"\";\n\n        for (let i = 0; i < coefs.length; i++) {\n            result += signs[i] + coefs[i];\n        }\n\n        return result;\n    }\n\n    /**\n     *  bisection\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *  @param {number} [TOLERANCE]\n     *  @param {number} [ACCURACY]\n     *  @returns {number}\n     */\n    bisection(min, max, TOLERANCE = 1e-6, ACCURACY = 15) {\n        let minValue = this.eval(min);\n        let maxValue = this.eval(max);\n        let result;\n\n        if (Math.abs(minValue) <= TOLERANCE) {\n            result = min;\n        }\n        else if (Math.abs(maxValue) <= TOLERANCE) {\n            result = max;\n        }\n        else if (minValue * maxValue <= 0) {\n            const tmp1 = Math.log(max - min);\n            const tmp2 = Math.LN10 * ACCURACY;\n            const maxIterations = Math.ceil((tmp1 + tmp2) / Math.LN2);\n\n            for (let i = 0; i < maxIterations; i++) {\n                result = 0.5 * (min + max);\n                const value = this.eval(result);\n\n                if (Math.abs(value) <= TOLERANCE) {\n                    break;\n                }\n\n                if (value * minValue < 0) {\n                    max = result;\n                    maxValue = value;\n                }\n                else {\n                    min = result;\n                    minValue = value;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     *  Based on trapzd in \"Numerical Recipes in C, 2nd Edition\", page 137\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *  @param {number} n\n     *  @returns {number}\n     */\n    trapezoid(min, max, n) {\n        if (isNaN(min) || isNaN(max) || isNaN(n)) {\n            throw new TypeError(\"Parameters must be numbers\");\n        }\n\n        const range = max - min;\n\n        if (n === 1) {\n            const minValue = this.eval(min);\n            const maxValue = this.eval(max);\n\n            this._s = 0.5 * range * (minValue + maxValue);\n        }\n        else {\n            const iter = 1 << (n - 2);\n            const delta = range / iter;\n            let x = min + 0.5 * delta;\n            let sum = 0;\n\n            for (let i = 0; i < iter; i++) {\n                sum += this.eval(x);\n                x += delta;\n            }\n\n            this._s = 0.5 * (this._s + range * sum / iter);\n        }\n\n        if (isNaN(this._s)) {\n            throw new TypeError(\"this._s is NaN\");\n        }\n\n        return this._s;\n    }\n\n    /**\n     *  Based on trapzd in \"Numerical Recipes in C, 2nd Edition\", page 139\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *  @returns {number}\n     */\n    simpson(min, max) {\n        if (isNaN(min) || isNaN(max)) {\n            throw new TypeError(\"Parameters must be numbers\");\n        }\n\n        const range = max - min;\n        let st = 0.5 * range * (this.eval(min) + this.eval(max));\n        let t = st;\n        let s = 4.0 * st / 3.0;\n        let os = s;\n        let ost = st;\n        const TOLERANCE = 1e-7;\n\n        let iter = 1;\n\n        for (let n = 2; n <= 20; n++) {\n            const delta = range / iter;\n            let x = min + 0.5 * delta;\n            let sum = 0;\n\n            for (let i = 1; i <= iter; i++) {\n                sum += this.eval(x);\n                x += delta;\n            }\n\n            t = 0.5 * (t + range * sum / iter);\n            st = t;\n            s = (4.0 * st - ost) / 3.0;\n\n            if (Math.abs(s - os) < TOLERANCE * Math.abs(os)) {\n                break;\n            }\n\n            os = s;\n            ost = st;\n            iter <<= 1;\n        }\n\n        return s;\n    }\n\n    /**\n     *  romberg\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *  @returns {number}\n     */\n    romberg(min, max) {\n        if (isNaN(min) || isNaN(max)) {\n            throw new TypeError(\"Parameters must be numbers\");\n        }\n\n        const MAX = 20;\n        const K = 3;\n        const TOLERANCE = 1e-6;\n        const s = new Array(MAX + 1);\n        const h = new Array(MAX + 1);\n        let result = {y: 0, dy: 0};\n\n        h[0] = 1.0;\n\n        for (let j = 1; j <= MAX; j++) {\n            s[j - 1] = this.trapezoid(min, max, j);\n\n            if (j >= K) {\n                result = Polynomial.interpolate(h, s, K, j - K, 0.0);\n                if (Math.abs(result.dy) <= TOLERANCE * result.y) {\n                    break;\n                }\n            }\n\n            s[j] = s[j - 1];\n            h[j] = 0.25 * h[j - 1];\n        }\n\n        return result.y;\n    }\n\n    /**\n     *  Estimate what is the maximum polynomial evaluation error value under which polynomial evaluation could be in fact 0.\n     *\n     *  @param {number} maxAbsX\n     *  @returns {number}\n     */\n    zeroErrorEstimate(maxAbsX) {\n        const poly = this;\n        const ERRF = 1e-15;\n\n        if (typeof maxAbsX === \"undefined\") {\n            const rb = poly.bounds();\n\n            maxAbsX = Math.max(Math.abs(rb.minX), Math.abs(rb.maxX));\n        }\n\n        if (maxAbsX < 0.001) {\n            return 2 * Math.abs(poly.eval(ERRF));\n        }\n\n        const n = poly.coefs.length - 1;\n        const an = poly.coefs[n];\n\n        return 10 * ERRF * poly.coefs.reduce((m, v, i) => {\n            const nm = v / an * Math.pow(maxAbsX, i);\n            return nm > m ? nm : m;\n        }, 0);\n    }\n\n    /**\n     *  Calculates upper Real roots bounds. <br/>\n     *  Real roots are in interval [negX, posX]. Determined by Fujiwara method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *\n     *  @returns {{ negX: number, posX: number }}\n     */\n    boundsUpperRealFujiwara() {\n        let a = this.coefs;\n        const n = a.length - 1;\n        const an = a[n];\n\n        if (an !== 1) {\n            a = this.coefs.map(v => v / an);\n        }\n\n        const b = a.map((v, i) => {\n            return (i < n)\n                ? Math.pow(Math.abs((i === 0) ? v / 2 : v), 1 / (n - i))\n                : v;\n        });\n\n        let coefSelectionFunc;\n        const find2Max = function(acc, bi, i) {\n            if (coefSelectionFunc(i)) {\n                if (acc.max < bi) {\n                    acc.nearmax = acc.max;\n                    acc.max = bi;\n                }\n                else if (acc.nearmax < bi) {\n                    acc.nearmax = bi;\n                }\n            }\n            return acc;\n        };\n\n        coefSelectionFunc = function(i) {\n            return i < n && a[i] < 0;\n        };\n\n        // eslint-disable-next-line unicorn/no-fn-reference-in-iterator\n        const max_nearmax_pos = b.reduce(find2Max, {max: 0, nearmax: 0});\n\n        coefSelectionFunc = function(i) {\n            return i < n && ((n % 2 === i % 2) ? a[i] < 0 : a[i] > 0);\n        };\n\n        // eslint-disable-next-line unicorn/no-fn-reference-in-iterator\n        const max_nearmax_neg = b.reduce(find2Max, {max: 0, nearmax: 0});\n\n        return {\n            negX: -2 * max_nearmax_neg.max,\n            posX: 2 * max_nearmax_pos.max\n        };\n    }\n\n    /**\n     *  Calculates lower Real roots bounds. <br/>\n     *  There are no Real roots in interval <negX, posX>. Determined by Fujiwara method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *\n     *  @returns {{ negX: number, posX: number }}\n     */\n    boundsLowerRealFujiwara() {\n        const poly = new Polynomial();\n\n        poly.coefs = this.coefs.slice().reverse();\n\n        const res = poly.boundsUpperRealFujiwara();\n\n        res.negX = 1 / res.negX;\n        res.posX = 1 / res.posX;\n\n        return res;\n    }\n\n    /**\n     *  Calculates left and right Real roots bounds. <br/>\n     *  Real roots are in interval [minX, maxX]. Combines Fujiwara lower and upper bounds to get minimal interval.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *\n     *  @returns {{ minX: number, maxX: number }}\n    */\n    bounds() {\n        const urb = this.boundsUpperRealFujiwara();\n        const rb = {minX: urb.negX, maxX: urb.posX};\n\n        if (urb.negX === 0 && urb.posX === 0) {\n            return rb;\n        }\n\n        if (urb.negX === 0) {\n            rb.minX = this.boundsLowerRealFujiwara().posX;\n        }\n        else if (urb.posX === 0) {\n            rb.maxX = this.boundsLowerRealFujiwara().negX;\n        }\n\n        if (rb.minX > rb.maxX) {\n            rb.minX = rb.maxX = 0;\n        }\n\n        return rb;\n        // TODO: if sure that there are no complex roots\n        // (maybe by using Sturm's theorem) use:\n        // return this.boundsRealLaguerre();\n    }\n\n    /**\n     *  Calculates absolute upper roots bound. <br/>\n     *  All (Complex and Real) roots magnitudes are &lt;= result. Determined by Rouche method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *\n     *  @returns {number}\n     */\n    boundUpperAbsRouche() {\n        const a = this.coefs;\n        const n = a.length - 1;\n        const max = a.reduce((prev, curr, i) => {\n            if (i !== n) {\n                curr = Math.abs(curr);\n                return (prev < curr) ? curr : prev;\n            }\n            return prev;\n        }, 0);\n\n        return 1 + max / Math.abs(a[n]);\n    }\n\n    /**\n     *  Calculates absolute lower roots bound. <br/>\n     *  All (Complex and Real) roots magnitudes are &gt;= result. Determined by Rouche method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *\n     *  @returns {number}\n     */\n    boundLowerAbsRouche() {\n        const a = this.coefs;\n        const max = a.reduce((prev, curr, i) => {\n            if (i !== 0) {\n                curr = Math.abs(curr);\n                return (prev < curr) ? curr : prev;\n            }\n            return prev;\n        }, 0);\n\n        return Math.abs(a[0]) / (Math.abs(a[0]) + max);\n    }\n\n    /**\n     *  Calculates left and right Real roots bounds.<br/>\n     *  WORKS ONLY if all polynomial roots are Real.\n     *  Real roots are in interval [minX, maxX]. Determined by Laguerre method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *\n     *  @returns {{ minX: number, maxX: number }}\n     */\n    boundsRealLaguerre() {\n        const a = this.coefs;\n        const n = a.length - 1;\n        const p1 = -a[n - 1] / (n * a[n]);\n        const undersqrt = a[n - 1] * a[n - 1] - 2 * n / (n - 1) * a[n] * a[n - 2];\n        let p2 = (n - 1) / (n * a[n]) * Math.sqrt(undersqrt);\n\n        if (p2 < 0) {\n            p2 = -p2;\n        }\n\n        return {\n            minX: p1 - p2,\n            maxX: p1 + p2\n        };\n    }\n\n    /**\n     *  Root count by Descartes rule of signs. <br/>\n     *  Returns maximum number of positive and negative real roots and minimum number of complex roots.\n     *  @see {@link http://en.wikipedia.org/wiki/Descartes%27_rule_of_signs}\n     *\n     *  @returns {{maxRealPos: number, maxRealNeg: number, minComplex: number}}\n     */\n    countRootsDescartes() {\n        const a = this.coefs;\n        const n = a.length - 1;\n        const accum = a.reduce((acc, ai, i) => {\n            if (acc.prev_a !== 0 && ai !== 0) {\n                if ((acc.prev_a < 0) === (ai > 0)) {\n                    acc.pos++;\n                }\n                if (((i % 2 === 0) !== (acc.prev_a < 0)) === ((i % 2 === 1) !== (ai > 0))) {\n                    acc.neg++;\n                }\n            }\n            acc.prev_a = ai;\n            return acc;\n        }, {pos: 0, neg: 0, prev_a: 0});\n\n        return {\n            maxRealPos: accum.pos,\n            maxRealNeg: accum.neg,\n            minComplex: n - (accum.pos + accum.neg)\n        };\n    }\n\n    // getters and setters\n\n    /**\n     *  get degree\n     *\n     *  @returns {number}\n     */\n    getDegree() {\n        return this.coefs.length - 1;\n    }\n\n    /**\n     *  getDerivative\n     *\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    getDerivative() {\n        const derivative = new Polynomial();\n\n        for (let i = 1; i < this.coefs.length; i++) {\n            derivative.coefs.push(i * this.coefs[i]);\n        }\n\n        return derivative;\n    }\n\n    /**\n     *  getRoots\n     *\n     *  @returns {Array<number>}\n     */\n    getRoots() {\n        let result;\n\n        this.simplifyEquals();\n\n        switch (this.getDegree()) {\n            case 0: result = []; break;\n            case 1: result = this.getLinearRoot(); break;\n            case 2: result = this.getQuadraticRoots(); break;\n            case 3: result = this.getCubicRoots(); break;\n            case 4: result = this.getQuarticRoots(); break;\n            default:\n                result = [];\n        }\n\n        return result;\n    }\n\n    /**\n     *  getRootsInInterval\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *  @returns {Array<number>}\n     */\n    getRootsInInterval(min, max) {\n        const roots = [];\n\n        /**\n         *  @param {number} value\n         */\n        function push(value) {\n            if (typeof value === \"number\") {\n                roots.push(value);\n            }\n        }\n\n        if (this.getDegree() === 0) {\n            throw new RangeError(\"Unexpected empty polynomial\");\n        }\n        else if (this.getDegree() === 1) {\n            push(this.bisection(min, max));\n        }\n        else {\n            // get roots of derivative\n            const deriv = this.getDerivative();\n            const droots = deriv.getRootsInInterval(min, max);\n\n            if (droots.length > 0) {\n                // find root on [min, droots[0]]\n                push(this.bisection(min, droots[0]));\n\n                // find root on [droots[i],droots[i+1]] for 0 <= i <= count-2\n                for (let i = 0; i <= droots.length - 2; i++) {\n                    push(this.bisection(droots[i], droots[i + 1]));\n                }\n\n                // find root on [droots[count-1],xmax]\n                push(this.bisection(droots[droots.length - 1], max));\n            }\n            else {\n                // polynomial is monotone on [min,max], has at most one root\n                push(this.bisection(min, max));\n            }\n        }\n\n        return roots;\n    }\n\n    /**\n     *  getLinearRoot\n     *\n     *  @returns {number}\n     */\n    getLinearRoot() {\n        const result = [];\n        const a = this.coefs[1];\n\n        if (a !== 0) {\n            result.push(-this.coefs[0] / a);\n        }\n\n        return result;\n    }\n\n    /**\n     *  getQuadraticRoots\n     *\n     *  @returns {Array<number>}\n     */\n    getQuadraticRoots() {\n        const results = [];\n\n        if (this.getDegree() === 2) {\n            const a = this.coefs[2];\n            const b = this.coefs[1] / a;\n            const c = this.coefs[0] / a;\n            const d = b * b - 4 * c;\n\n            if (d > 0) {\n                const e = Math.sqrt(d);\n\n                results.push(0.5 * (-b + e));\n                results.push(0.5 * (-b - e));\n            }\n            else if (d === 0) {\n                // really two roots with same value, but we only return one\n                results.push(0.5 * -b);\n            }\n            // else imaginary results\n        }\n\n        return results;\n    }\n\n    /**\n     *  getCubicRoots\n     *\n     *  This code is based on MgcPolynomial.cpp written by David Eberly.  His\n     *  code along with many other excellent examples are avaiable at his site:\n     *  http://www.geometrictools.com\n     *\n     *  @returns {Array<number>}\n     */\n    getCubicRoots() {\n        const results = [];\n\n        if (this.getDegree() === 3) {\n            const c3 = this.coefs[3];\n            const c2 = this.coefs[2] / c3;\n            const c1 = this.coefs[1] / c3;\n            const c0 = this.coefs[0] / c3;\n\n            const a = (3 * c1 - c2 * c2) / 3;\n            const b = (2 * c2 * c2 * c2 - 9 * c1 * c2 + 27 * c0) / 27;\n            const offset = c2 / 3;\n            let discrim = b * b / 4 + a * a * a / 27;\n            const halfB = b / 2;\n\n            const ZEROepsilon = this.zeroErrorEstimate();\n\n            if (Math.abs(discrim) <= ZEROepsilon) {\n                discrim = 0;\n            }\n\n            if (discrim > 0) {\n                const e = Math.sqrt(discrim);\n                let root; // eslint-disable-line no-shadow\n\n                let tmp = -halfB + e;\n\n                if (tmp >= 0) {\n                    root = Math.pow(tmp, 1 / 3);\n                }\n                else {\n                    root = -Math.pow(-tmp, 1 / 3);\n                }\n\n                tmp = -halfB - e;\n\n                if (tmp >= 0) {\n                    root += Math.pow(tmp, 1 / 3);\n                }\n                else {\n                    root -= Math.pow(-tmp, 1 / 3);\n                }\n\n                results.push(root - offset);\n            }\n            else if (discrim < 0) {\n                const distance = Math.sqrt(-a / 3);\n                const angle = Math.atan2(Math.sqrt(-discrim), -halfB) / 3;\n                const cos = Math.cos(angle);\n                const sin = Math.sin(angle);\n                const sqrt3 = Math.sqrt(3);\n\n                results.push(2 * distance * cos - offset);\n                results.push(-distance * (cos + sqrt3 * sin) - offset);\n                results.push(-distance * (cos - sqrt3 * sin) - offset);\n            }\n            else {\n                let tmp;\n\n                if (halfB >= 0) {\n                    tmp = -Math.pow(halfB, 1 / 3);\n                }\n                else {\n                    tmp = Math.pow(-halfB, 1 / 3);\n                }\n\n                results.push(2 * tmp - offset);\n                // really should return next root twice, but we return only one\n                results.push(-tmp - offset);\n            }\n        }\n\n        return results;\n    }\n\n    /**\n     *  Calculates roots of quartic polynomial. <br/>\n     *  First, derivative roots are found, then used to split quartic polynomial\n     *  into segments, each containing one root of quartic polynomial.\n     *  Segments are then passed to newton's method to find roots.\n     *\n     *  @returns {Array<number>} roots\n     */\n    getQuarticRoots() {\n        let results = [];\n        const n = this.getDegree();\n\n        if (n === 4) {\n            const poly = new Polynomial();\n\n            poly.coefs = this.coefs.slice();\n            poly.divideEqualsScalar(poly.coefs[n]);\n\n            const ERRF = 1e-15;\n\n            if (Math.abs(poly.coefs[0]) < 10 * ERRF * Math.abs(poly.coefs[3])) {\n                poly.coefs[0] = 0;\n            }\n\n            const poly_d = poly.getDerivative();\n            const derrt = poly_d.getRoots().sort((a, b) => a - b);\n            const dery = [];\n            const nr = derrt.length - 1;\n            const rb = this.bounds();\n\n            const maxabsX = Math.max(Math.abs(rb.minX), Math.abs(rb.maxX));\n            const ZEROepsilon = this.zeroErrorEstimate(maxabsX);\n\n            for (let i = 0; i <= nr; i++) {\n                dery.push(poly.eval(derrt[i]));\n            }\n\n            for (let i = 0; i <= nr; i++) {\n                if (Math.abs(dery[i]) < ZEROepsilon) {\n                    dery[i] = 0;\n                }\n            }\n\n            let i = 0;\n            const dx = Math.max(0.1 * (rb.maxX - rb.minX) / n, ERRF);\n            const guesses = [];\n            const minmax = [];\n\n            if (nr > -1) {\n                if (dery[0] !== 0) {\n                    if (sign(dery[0]) !== sign(poly.eval(derrt[0] - dx) - dery[0])) {\n                        guesses.push(derrt[0] - dx);\n                        minmax.push([rb.minX, derrt[0]]);\n                    }\n                }\n                else {\n                    results.push(derrt[0], derrt[0]);\n                    i++;\n                }\n\n                for (; i < nr; i++) {\n                    if (dery[i + 1] === 0) {\n                        results.push(derrt[i + 1], derrt[i + 1]);\n                        i++;\n                    }\n                    else if (sign(dery[i]) !== sign(dery[i + 1])) {\n                        guesses.push((derrt[i] + derrt[i + 1]) / 2);\n                        minmax.push([derrt[i], derrt[i + 1]]);\n                    }\n                }\n                if (dery[nr] !== 0 && sign(dery[nr]) !== sign(poly.eval(derrt[nr] + dx) - dery[nr])) {\n                    guesses.push(derrt[nr] + dx);\n                    minmax.push([derrt[nr], rb.maxX]);\n                }\n            }\n\n            /**\n             *  @param {number} x\n             *  @returns {number}\n             */\n            const f = function(x) {\n                return poly.eval(x);\n            };\n\n            /**\n             *  @param {number} x\n             *  @returns {number}\n             */\n            const df = function(x) {\n                return poly_d.eval(x);\n            };\n\n            if (guesses.length > 0) {\n                for (i = 0; i < guesses.length; i++) {\n                    guesses[i] = Polynomial.newtonSecantBisection(guesses[i], f, df, 32, minmax[i][0], minmax[i][1]);\n                }\n            }\n\n            results = results.concat(guesses);\n        }\n\n        return results;\n    }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Polynomial);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2tsZC1wb2x5bm9taWFsQDAuMy4wL25vZGVfbW9kdWxlcy9rbGQtcG9seW5vbWlhbC9saWIvUG9seW5vbWlhbC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaURBQWlEO0FBQ25FO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0Isa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLE9BQU87QUFDL0Isd0JBQXdCLFdBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsY0FBYztBQUNkLGNBQWM7QUFDZDtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixVQUFVO0FBQzFCLGdC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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEMsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEMsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsVUFBVSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHJlcG9ncmFwaC93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2tsZC1wb2x5bm9taWFsQDAuMy4wL25vZGVfbW9kdWxlcy9rbGQtcG9seW5vbWlhbC9saWIvUG9seW5vbWlhbC5qcz8zNTUzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuLyoqXG4gKiAgUG9seW5vbWlhbC5qc1xuICpcbiAqICBAbW9kdWxlIFBvbHlub21pYWxcbiAqICBAY29weXJpZ2h0IDIwMDItMjAxOSBLZXZpbiBMaW5kc2V5PGJyPlxuICogIC08YnI+XG4gKiAgQ29udHJpYnV0aW9uIHtAbGluayBodHRwOi8vZ2l0aHViLmNvbS9RdWF6aXN0YXgva2xkLXBvbHlub21pYWx9PGJyPlxuICogIGNvcHlyaWdodCAyMDE1IFJvYmVydCBCZW5rbyAoUXVhemlzdGF4KSA8cXVhemlzdGF4QGdtYWlsLmNvbT48YnI+XG4gKiAgTUlUIGxpY2Vuc2VcbiAqL1xuXG4vKipcbiAqICBTaWduIG9mIGEgbnVtYmVyICgrMSwgLTEsICswLCAtMCkuXG4gKlxuICogIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiAgQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gc2lnbih4KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIHJldHVybiB0eXBlb2YgeCA9PT0gXCJudW1iZXJcIiA/IHggPyB4IDwgMCA/IC0xIDogMSA6IHggPT09IHggPyB4IDogTmFOIDogTmFOO1xufVxuXG4vKipcbiAqICBQb2x5bm9taWFsXG4gKlxuICogIEBtZW1iZXJvZiBtb2R1bGU6a2xkLXBvbHlub21pYWxcbiAqL1xuY2xhc3MgUG9seW5vbWlhbCB7XG4gICAgLyoqXG4gICAgICogIFBvbHlub21pYWxcbiAgICAgKlxuICAgICAqICBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNvZWZzXG4gICAgICogIEByZXR1cm5zIHttb2R1bGU6a2xkLXBvbHlub21pYWwuUG9seW5vbWlhbH1cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciguLi5jb2Vmcykge1xuICAgICAgICB0aGlzLmNvZWZzID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IGNvZWZzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB0aGlzLmNvZWZzLnB1c2goY29lZnNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdmFyaWFibGUgPSBcInRcIjtcbiAgICAgICAgdGhpcy5fcyA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIEJhc2VkIG9uIHBvbGludCBpbiBcIk51bWVyaWNhbCBSZWNpcGVzIGluIEMsIDJuZCBFZGl0aW9uXCIsIHBhZ2VzIDEwOS0xMTBcbiAgICAgKlxuICAgICAqICBAcGFyYW0ge0FycmF5PG51bWJlcj59IHhzXG4gICAgICogIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geXNcbiAgICAgKiAgQHBhcmFtIHtudW1iZXJ9IG5cbiAgICAgKiAgQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgICAqICBAcGFyYW0ge251bWJlcn0geFxuICAgICAqXG4gICAgICogIEByZXR1cm5zIHt7eTogbnVtYmVyLCBkeTogbnVtYmVyfX1cbiAgICAgKi9cbiAgICBzdGF0aWMgaW50ZXJwb2xhdGUoeHMsIHlzLCBuLCBvZmZzZXQsIHgpIHtcbiAgICAgICAgaWYgKHhzLmNvbnN0cnVjdG9yICE9PSBBcnJheSB8fCB5cy5jb25zdHJ1Y3RvciAhPT0gQXJyYXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ4cyBhbmQgeXMgbXVzdCBiZSBhcnJheXNcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFOKG4pIHx8IGlzTmFOKG9mZnNldCkgfHwgaXNOYU4oeCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJuLCBvZmZzZXQsIGFuZCB4IG11c3QgYmUgbnVtYmVyc1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpLCB5O1xuICAgICAgICBsZXQgZHkgPSAwO1xuICAgICAgICBjb25zdCBjID0gbmV3IEFycmF5KG4pO1xuICAgICAgICBjb25zdCBkID0gbmV3IEFycmF5KG4pO1xuICAgICAgICBsZXQgbnMgPSAwO1xuXG4gICAgICAgIGxldCBkaWZmID0gTWF0aC5hYnMoeCAtIHhzW29mZnNldF0pO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZnQgPSBNYXRoLmFicyh4IC0geHNbb2Zmc2V0ICsgaV0pO1xuXG4gICAgICAgICAgICBpZiAoZGlmdCA8IGRpZmYpIHtcbiAgICAgICAgICAgICAgICBucyA9IGk7XG4gICAgICAgICAgICAgICAgZGlmZiA9IGRpZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjW2ldID0gZFtpXSA9IHlzW29mZnNldCArIGldO1xuICAgICAgICB9XG5cbiAgICAgICAgeSA9IHlzW29mZnNldCArIG5zXTtcbiAgICAgICAgbnMtLTtcblxuICAgICAgICBmb3IgKGxldCBtID0gMTsgbSA8IG47IG0rKykge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG4gLSBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBobyA9IHhzW29mZnNldCArIGldIC0geDtcbiAgICAgICAgICAgICAgICBjb25zdCBocCA9IHhzW29mZnNldCArIGkgKyBtXSAtIHg7XG4gICAgICAgICAgICAgICAgY29uc3QgdyA9IGNbaSArIDFdIC0gZFtpXTtcbiAgICAgICAgICAgICAgICBsZXQgZGVuID0gaG8gLSBocDtcblxuICAgICAgICAgICAgICAgIGlmIChkZW4gPT09IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlVuYWJsZSB0byBpbnRlcnBvbGF0ZSBwb2x5bm9taWFsLiBUd28gbnVtYmVycyBpbiBuIHdlcmUgaWRlbnRpY2FsICh0byB3aXRoaW4gcm91bmRvZmYpXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlbiA9IHcgLyBkZW47XG4gICAgICAgICAgICAgICAgZFtpXSA9IGhwICogZGVuO1xuICAgICAgICAgICAgICAgIGNbaV0gPSBobyAqIGRlbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZHkgPSAoMiAqIChucyArIDEpIDwgKG4gLSBtKSkgPyBjW25zICsgMV0gOiBkW25zLS1dO1xuICAgICAgICAgICAgeSArPSBkeTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7eSwgZHl9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBOZXd0b24ncyAoTmV3dG9uLVJhcGhzb24pIG1ldGhvZCBmb3IgZmluZGluZyBSZWFsIHJvb3RzIG9uIHVuaXZhcmlhdGUgZnVuY3Rpb24uIDxici8+XG4gICAgICogIFdoZW4gdXNpbmcgYm91bmRzLCBhbGdvcml0aG0gZmFsbHMgYmFjayB0byBzZWNhbnQgaWYgbmV3dG9uIGdvZXMgb3V0IG9mIHJhbmdlLlxuICAgICAqICBCaXNlY3Rpb24gaXMgZmFsbGJhY2sgZm9yIHNlY2FudCB3aGVuIGRldGVybWluZWQgc2VjYW50IGlzIG5vdCBlZmZpY2llbnQgZW5vdWdoLlxuICAgICAqICBAc2VlIHtAbGluayBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL05ld3RvbiUyN3NfbWV0aG9kfVxuICAgICAqICBAc2VlIHtAbGluayBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NlY2FudF9tZXRob2R9XG4gICAgICogIEBzZWUge0BsaW5rIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmlzZWN0aW9uX21ldGhvZH1cbiAgICAgKlxuICAgICAqICBAcGFyYW0ge251bWJlcn0geDAgLSBJbml0aWFsIHJvb3QgZ3Vlc3NcbiAgICAgKiAgQHBhcmFtIHtGdW5jdGlvbn0gZiAtIEZ1bmN0aW9uIHdoaWNoIHJvb3Qgd2UgYXJlIHRyeWluZyB0byBmaW5kXG4gICAgICogIEBwYXJhbSB7RnVuY3Rpb259IGRmIC0gRGVyaXZhdGl2ZSBvZiBmdW5jdGlvbiBmXG4gICAgICogIEBwYXJhbSB7bnVtYmVyfSBtYXhfaXRlcmF0aW9ucyAtIE1heGltdW0gbnVtYmVyIG9mIGFsZ29yaXRobSBpdGVyYXRpb25zXG4gICAgICogIEBwYXJhbSB7bnVtYmVyfSBbbWluXSAtIExlZnQgYm91bmQgdmFsdWVcbiAgICAgKiAgQHBhcmFtIHtudW1iZXJ9IFttYXhdIC0gUmlnaHQgYm91bmQgdmFsdWVcbiAgICAgKiAgQHJldHVybnMge251bWJlcn0gcm9vdFxuICAgICAqL1xuICAgIHN0YXRpYyBuZXd0b25TZWNhbnRCaXNlY3Rpb24oeDAsIGYsIGRmLCBtYXhfaXRlcmF0aW9ucywgbWluLCBtYXgpIHtcbiAgICAgICAgbGV0IHgsIHByZXZfZGZ4ID0gMCwgZGZ4LCBwcmV2X3hfZWZfY29ycmVjdGlvbiA9IDAsIHhfY29ycmVjdGlvbiwgeF9uZXc7XG4gICAgICAgIGxldCB5LCB5X2F0bWluLCB5X2F0bWF4O1xuXG4gICAgICAgIHggPSB4MDtcblxuICAgICAgICBjb25zdCBBQ0NVUkFDWSA9IDE0O1xuICAgICAgICBjb25zdCBtaW5fY29ycmVjdGlvbl9mYWN0b3IgPSBNYXRoLnBvdygxMCwgLUFDQ1VSQUNZKTtcbiAgICAgICAgY29uc3QgaXNCb3VuZGVkID0gKHR5cGVvZiBtaW4gPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIG1heCA9PT0gXCJudW1iZXJcIik7XG5cbiAgICAgICAgaWYgKGlzQm91bmRlZCkge1xuICAgICAgICAgICAgaWYgKG1pbiA+IG1heCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTWluIG11c3QgYmUgZ3JlYXRlciB0aGFuIG1heFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeV9hdG1pbiA9IGYobWluKTtcbiAgICAgICAgICAgIHlfYXRtYXggPSBmKG1heCk7XG5cbiAgICAgICAgICAgIGlmIChzaWduKHlfYXRtaW4pID09PSBzaWduKHlfYXRtYXgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJZIHZhbHVlcyBvZiBib3VuZHMgbXVzdCBiZSBvZiBvcHBvc2l0ZSBzaWduXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNFbm91Z2hDb3JyZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBzdG9wIGlmIGNvcnJlY3Rpb24gaXMgdG9vIHNtYWxsIG9yIGlmIGNvcnJlY3Rpb24gaXMgaW4gc2ltcGxlIGxvb3BcbiAgICAgICAgICAgIHJldHVybiAoTWF0aC5hYnMoeF9jb3JyZWN0aW9uKSA8PSBtaW5fY29ycmVjdGlvbl9mYWN0b3IgKiBNYXRoLmFicyh4KSkgfHxcbiAgICAgICAgICAgICAgICAocHJldl94X2VmX2NvcnJlY3Rpb24gPT09ICh4IC0geF9jb3JyZWN0aW9uKSAtIHgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4X2l0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICAgICAgZGZ4ID0gZGYoeCk7XG5cbiAgICAgICAgICAgIGlmIChkZnggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocHJldl9kZnggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJkZih4KSBpcyB6ZXJvXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlIHByZXZpb3VzIGRlcml2YXRpb24gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgZGZ4ID0gcHJldl9kZng7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG9yIG1vdmUgeCBhIGxpdHRsZT9cbiAgICAgICAgICAgICAgICAvLyBkZnggPSBkZih4ICE9IDAgPyB4ICsgeCAqIDFlLTE1IDogMWUtMTUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmV2X2RmeCA9IGRmeDtcbiAgICAgICAgICAgIHkgPSBmKHgpO1xuICAgICAgICAgICAgeF9jb3JyZWN0aW9uID0geSAvIGRmeDtcbiAgICAgICAgICAgIHhfbmV3ID0geCAtIHhfY29ycmVjdGlvbjtcblxuICAgICAgICAgICAgaWYgKGlzRW5vdWdoQ29ycmVjdGlvbigpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0JvdW5kZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2lnbih5KSA9PT0gc2lnbih5X2F0bWF4KSkge1xuICAgICAgICAgICAgICAgICAgICBtYXggPSB4O1xuICAgICAgICAgICAgICAgICAgICB5X2F0bWF4ID0geTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2lnbih5KSA9PT0gc2lnbih5X2F0bWluKSkge1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSB4O1xuICAgICAgICAgICAgICAgICAgICB5X2F0bWluID0geTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSB4X25ldztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCh4X25ldyA8IG1pbikgfHwgKHhfbmV3ID4gbWF4KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lnbih5X2F0bWluKSA9PT0gc2lnbih5X2F0bWF4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBSQVRJT19MSU1JVCA9IDUwO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBBSU1FRF9CSVNFQ1RfT0ZGU0VUID0gMC4yNTsgLy8gWzAsIDAuNSlcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZHkgPSB5X2F0bWF4IC0geV9hdG1pbjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZHggPSBtYXggLSBtaW47XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGR5ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4X2NvcnJlY3Rpb24gPSB4IC0gKG1pbiArIGR4ICogMC41KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChNYXRoLmFicyhkeSAvIE1hdGgubWluKHlfYXRtaW4sIHlfYXRtYXgpKSA+IFJBVElPX0xJTUlUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4X2NvcnJlY3Rpb24gPSB4IC0gKG1pbiArIGR4ICogKDAuNSArIChNYXRoLmFicyh5X2F0bWluKSA8IE1hdGguYWJzKHlfYXRtYXgpID8gLUFJTUVEX0JJU0VDVF9PRkZTRVQgOiBBSU1FRF9CSVNFQ1RfT0ZGU0VUKSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgeF9jb3JyZWN0aW9uID0geCAtIChtaW4gLSB5X2F0bWluIC8gZHkgKiBkeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeF9uZXcgPSB4IC0geF9jb3JyZWN0aW9uO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Vub3VnaENvcnJlY3Rpb24oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXZfeF9lZl9jb3JyZWN0aW9uID0geCAtIHhfbmV3O1xuICAgICAgICAgICAgeCA9IHhfbmV3O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIENsb25lcyB0aGlzIHBvbHlub21pYWwgYW5kIHJldHVybiB0aGUgY2xvbmUuXG4gICAgICpcbiAgICAgKiAgQHJldHVybnMge21vZHVsZTprbGQtcG9seW5vbWlhbC5Qb2x5bm9taWFsfVxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBwb2x5ID0gbmV3IFBvbHlub21pYWwoKTtcblxuICAgICAgICBwb2x5LmNvZWZzID0gdGhpcy5jb2Vmcy5zbGljZSgpO1xuXG4gICAgICAgIHJldHVybiBwb2x5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBldmFsXG4gICAgICpcbiAgICAgKiAgQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKi9cbiAgICBldmFsKHgpIHtcbiAgICAgICAgaWYgKGlzTmFOKHgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgbXVzdCBiZSBhIG51bWJlci4gRm91bmQgJyR7eH0nYCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzdWx0ID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5jb2Vmcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICogeCArIHRoaXMuY29lZnNbaV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBhZGRcbiAgICAgKlxuICAgICAqICBAcGFyYW0ge21vZHVsZTprbGQtcG9seW5vbWlhbC5Qb2x5bm9taWFsfSB0aGF0XG4gICAgICogIEByZXR1cm5zIHttb2R1bGU6a2xkLXBvbHlub21pYWwuUG9seW5vbWlhbH1cbiAgICAgKi9cbiAgICBhZGQodGhhdCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgUG9seW5vbWlhbCgpO1xuICAgICAgICBjb25zdCBkMSA9IHRoaXMuZ2V0RGVncmVlKCk7XG4gICAgICAgIGNvbnN0IGQyID0gdGhhdC5nZXREZWdyZWUoKTtcbiAgICAgICAgY29uc3QgZG1heCA9IE1hdGgubWF4KGQxLCBkMik7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gZG1heDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB2MSA9IChpIDw9IGQxKSA/IHRoaXMuY29lZnNbaV0gOiAwO1xuICAgICAgICAgICAgY29uc3QgdjIgPSAoaSA8PSBkMikgPyB0aGF0LmNvZWZzW2ldIDogMDtcblxuICAgICAgICAgICAgcmVzdWx0LmNvZWZzW2ldID0gdjEgKyB2MjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIG11bHRpcGx5XG4gICAgICpcbiAgICAgKiAgQHBhcmFtIHttb2R1bGU6a2xkLXBvbHlub21pYWwuUG9seW5vbWlhbH0gdGhhdFxuICAgICAqICBAcmV0dXJucyB7bW9kdWxlOmtsZC1wb2x5bm9taWFsLlBvbHlub21pYWx9XG4gICAgICovXG4gICAgbXVsdGlwbHkodGhhdCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgUG9seW5vbWlhbCgpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHRoaXMuZ2V0RGVncmVlKCkgKyB0aGF0LmdldERlZ3JlZSgpOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5jb2Vmcy5wdXNoKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gdGhpcy5nZXREZWdyZWUoKTsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8PSB0aGF0LmdldERlZ3JlZSgpOyBqKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuY29lZnNbaSArIGpdICs9IHRoaXMuY29lZnNbaV0gKiB0aGF0LmNvZWZzW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgZGl2aWRlRXF1YWxzU2NhbGFyXG4gICAgICpcbiAgICAgKiAgQGRlcHJlY2F0ZWQgVG8gYmUgcmVwbGFjZWQgYnkgZGl2aWRlU2NhbGFyXG4gICAgICogIEBwYXJhbSB7bnVtYmVyfSBzY2FsYXJcbiAgICAgKi9cbiAgICBkaXZpZGVFcXVhbHNTY2FsYXIoc2NhbGFyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb2Vmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5jb2Vmc1tpXSAvPSBzY2FsYXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgc2ltcGxpZnlFcXVhbHNcbiAgICAgKlxuICAgICAqICBAZGVwcmVjYXRlZCBUbyBiZSByZXBsYWNlZCBieSBzaW1wbGlmeVxuICAgICAqICBAcGFyYW0ge251bWJlcn0gVE9MRVJBTkNFXG4gICAgICovXG4gICAgc2ltcGxpZnlFcXVhbHMoVE9MRVJBTkNFID0gMWUtMTIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZ2V0RGVncmVlKCk7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5jb2Vmc1tpXSkgPD0gVE9MRVJBTkNFKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2Vmcy5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFNldHMgc21hbGwgY29lZmZpY2llbnRzIHRvIHplcm8uXG4gICAgICpcbiAgICAgKiAgQGRlcHJlY2F0ZWQgVG8gYmUgcmVwbGFjZWQgYnkgcmVtb3ZlWmVyb3NcbiAgICAgKiAgQHBhcmFtIHtudW1iZXJ9IFRPTEVSQU5DRVxuICAgICAqICBAcmV0dXJucyB7bW9kdWxlOmtsZC1wb2x5bm9taWFsLlBvbHlub21pYWx9XG4gICAgICovXG4gICAgcmVtb3ZlWmVyb3NFcXVhbHMoVE9MRVJBTkNFID0gMWUtMTUpIHtcbiAgICAgICAgY29uc3QgYyA9IHRoaXMuY29lZnM7XG4gICAgICAgIGNvbnN0IGVyciA9IDEwICogVE9MRVJBTkNFICogTWF0aC5hYnMoXG4gICAgICAgICAgICBjLnJlZHVjZSgocHYsIGN2KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKGN2KSA+IE1hdGguYWJzKHB2KSA/IGN2IDogcHY7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhjW2ldKSA8IGVycikge1xuICAgICAgICAgICAgICAgIGNbaV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFNjYWxlcyBwb2x5bm9taWFsIHNvIHRoYXQgbGVhZGluZyBjb2VmZmljaWVudCBiZWNvbWVzIDEuXG4gICAgICpcbiAgICAgKiAgQGRlcHJlY2F0ZWQgVG8gYmUgcmVwbGFjZWQgYnkgZ2V0TW9uaWNcbiAgICAgKiAgQHJldHVybnMge21vZHVsZTprbGQtcG9seW5vbWlhbC5Qb2x5bm9taWFsfVxuICAgICAqL1xuICAgIG1vbmljRXF1YWxzKCkge1xuICAgICAgICBjb25zdCBjID0gdGhpcy5jb2VmcztcblxuICAgICAgICBpZiAoY1tjLmxlbmd0aCAtIDFdICE9PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmRpdmlkZUVxdWFsc1NjYWxhcihjW2MubGVuZ3RoIC0gMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIHRvU3RyaW5nXG4gICAgICpcbiAgICAgKiAgQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgY29uc3QgY29lZnMgPSBbXTtcbiAgICAgICAgY29uc3Qgc2lnbnMgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5jb2Vmcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gTWF0aC5yb3VuZCh0aGlzLmNvZWZzW2ldICogMTAwMCkgLyAxMDAwO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaWduU3RyaW5nID0gKHZhbHVlIDwgMCkgPyBcIiAtIFwiIDogXCIgKyBcIjtcblxuICAgICAgICAgICAgICAgIHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl92YXJpYWJsZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHRoaXMuX3ZhcmlhYmxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGkgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IFwiXlwiICsgaTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzaWducy5wdXNoKHNpZ25TdHJpbmcpO1xuICAgICAgICAgICAgICAgIGNvZWZzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2lnbnNbMF0gPSAoc2lnbnNbMF0gPT09IFwiICsgXCIpID8gXCJcIiA6IFwiLVwiO1xuXG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29lZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzaWduc1tpXSArIGNvZWZzW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgYmlzZWN0aW9uXG4gICAgICpcbiAgICAgKiAgQHBhcmFtIHtudW1iZXJ9IG1pblxuICAgICAqICBAcGFyYW0ge251bWJlcn0gbWF4XG4gICAgICogIEBwYXJhbSB7bnVtYmVyfSBbVE9MRVJBTkNFXVxuICAgICAqICBAcGFyYW0ge251bWJlcn0gW0FDQ1VSQUNZXVxuICAgICAqICBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGJpc2VjdGlvbihtaW4sIG1heCwgVE9MRVJBTkNFID0gMWUtNiwgQUNDVVJBQ1kgPSAxNSkge1xuICAgICAgICBsZXQgbWluVmFsdWUgPSB0aGlzLmV2YWwobWluKTtcbiAgICAgICAgbGV0IG1heFZhbHVlID0gdGhpcy5ldmFsKG1heCk7XG4gICAgICAgIGxldCByZXN1bHQ7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKG1pblZhbHVlKSA8PSBUT0xFUkFOQ0UpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG1pbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChNYXRoLmFicyhtYXhWYWx1ZSkgPD0gVE9MRVJBTkNFKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBtYXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWluVmFsdWUgKiBtYXhWYWx1ZSA8PSAwKSB7XG4gICAgICAgICAgICBjb25zdCB0bXAxID0gTWF0aC5sb2cobWF4IC0gbWluKTtcbiAgICAgICAgICAgIGNvbnN0IHRtcDIgPSBNYXRoLkxOMTAgKiBBQ0NVUkFDWTtcbiAgICAgICAgICAgIGNvbnN0IG1heEl0ZXJhdGlvbnMgPSBNYXRoLmNlaWwoKHRtcDEgKyB0bXAyKSAvIE1hdGguTE4yKTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhJdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAwLjUgKiAobWluICsgbWF4KTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZXZhbChyZXN1bHQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHZhbHVlKSA8PSBUT0xFUkFOQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICogbWluVmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heCA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgbWF4VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgbWluVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBCYXNlZCBvbiB0cmFwemQgaW4gXCJOdW1lcmljYWwgUmVjaXBlcyBpbiBDLCAybmQgRWRpdGlvblwiLCBwYWdlIDEzN1xuICAgICAqXG4gICAgICogIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAgICAgKiAgQHBhcmFtIHtudW1iZXJ9IG1heFxuICAgICAqICBAcGFyYW0ge251bWJlcn0gblxuICAgICAqICBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRyYXBlem9pZChtaW4sIG1heCwgbikge1xuICAgICAgICBpZiAoaXNOYU4obWluKSB8fCBpc05hTihtYXgpIHx8IGlzTmFOKG4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVycyBtdXN0IGJlIG51bWJlcnNcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByYW5nZSA9IG1heCAtIG1pbjtcblxuICAgICAgICBpZiAobiA9PT0gMSkge1xuICAgICAgICAgICAgY29uc3QgbWluVmFsdWUgPSB0aGlzLmV2YWwobWluKTtcbiAgICAgICAgICAgIGNvbnN0IG1heFZhbHVlID0gdGhpcy5ldmFsKG1heCk7XG5cbiAgICAgICAgICAgIHRoaXMuX3MgPSAwLjUgKiByYW5nZSAqIChtaW5WYWx1ZSArIG1heFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZXIgPSAxIDw8IChuIC0gMik7XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IHJhbmdlIC8gaXRlcjtcbiAgICAgICAgICAgIGxldCB4ID0gbWluICsgMC41ICogZGVsdGE7XG4gICAgICAgICAgICBsZXQgc3VtID0gMDtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdW0gKz0gdGhpcy5ldmFsKHgpO1xuICAgICAgICAgICAgICAgIHggKz0gZGVsdGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3MgPSAwLjUgKiAodGhpcy5fcyArIHJhbmdlICogc3VtIC8gaXRlcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNOYU4odGhpcy5fcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ0aGlzLl9zIGlzIE5hTlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBCYXNlZCBvbiB0cmFwemQgaW4gXCJOdW1lcmljYWwgUmVjaXBlcyBpbiBDLCAybmQgRWRpdGlvblwiLCBwYWdlIDEzOVxuICAgICAqXG4gICAgICogIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAgICAgKiAgQHBhcmFtIHtudW1iZXJ9IG1heFxuICAgICAqICBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIHNpbXBzb24obWluLCBtYXgpIHtcbiAgICAgICAgaWYgKGlzTmFOKG1pbikgfHwgaXNOYU4obWF4KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlcnMgbXVzdCBiZSBudW1iZXJzXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmFuZ2UgPSBtYXggLSBtaW47XG4gICAgICAgIGxldCBzdCA9IDAuNSAqIHJhbmdlICogKHRoaXMuZXZhbChtaW4pICsgdGhpcy5ldmFsKG1heCkpO1xuICAgICAgICBsZXQgdCA9IHN0O1xuICAgICAgICBsZXQgcyA9IDQuMCAqIHN0IC8gMy4wO1xuICAgICAgICBsZXQgb3MgPSBzO1xuICAgICAgICBsZXQgb3N0ID0gc3Q7XG4gICAgICAgIGNvbnN0IFRPTEVSQU5DRSA9IDFlLTc7XG5cbiAgICAgICAgbGV0IGl0ZXIgPSAxO1xuXG4gICAgICAgIGZvciAobGV0IG4gPSAyOyBuIDw9IDIwOyBuKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gcmFuZ2UgLyBpdGVyO1xuICAgICAgICAgICAgbGV0IHggPSBtaW4gKyAwLjUgKiBkZWx0YTtcbiAgICAgICAgICAgIGxldCBzdW0gPSAwO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBpdGVyOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdW0gKz0gdGhpcy5ldmFsKHgpO1xuICAgICAgICAgICAgICAgIHggKz0gZGVsdGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHQgPSAwLjUgKiAodCArIHJhbmdlICogc3VtIC8gaXRlcik7XG4gICAgICAgICAgICBzdCA9IHQ7XG4gICAgICAgICAgICBzID0gKDQuMCAqIHN0IC0gb3N0KSAvIDMuMDtcblxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHMgLSBvcykgPCBUT0xFUkFOQ0UgKiBNYXRoLmFicyhvcykpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3MgPSBzO1xuICAgICAgICAgICAgb3N0ID0gc3Q7XG4gICAgICAgICAgICBpdGVyIDw8PSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIHJvbWJlcmdcbiAgICAgKlxuICAgICAqICBAcGFyYW0ge251bWJlcn0gbWluXG4gICAgICogIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAgICAgKiAgQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICByb21iZXJnKG1pbiwgbWF4KSB7XG4gICAgICAgIGlmIChpc05hTihtaW4pIHx8IGlzTmFOKG1heCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXJzIG11c3QgYmUgbnVtYmVyc1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IE1BWCA9IDIwO1xuICAgICAgICBjb25zdCBLID0gMztcbiAgICAgICAgY29uc3QgVE9MRVJBTkNFID0gMWUtNjtcbiAgICAgICAgY29uc3QgcyA9IG5ldyBBcnJheShNQVggKyAxKTtcbiAgICAgICAgY29uc3QgaCA9IG5ldyBBcnJheShNQVggKyAxKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt5OiAwLCBkeTogMH07XG5cbiAgICAgICAgaFswXSA9IDEuMDtcblxuICAgICAgICBmb3IgKGxldCBqID0gMTsgaiA8PSBNQVg7IGorKykge1xuICAgICAgICAgICAgc1tqIC0gMV0gPSB0aGlzLnRyYXBlem9pZChtaW4sIG1heCwgaik7XG5cbiAgICAgICAgICAgIGlmIChqID49IEspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBQb2x5bm9taWFsLmludGVycG9sYXRlKGgsIHMsIEssIGogLSBLLCAwLjApO1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhyZXN1bHQuZHkpIDw9IFRPTEVSQU5DRSAqIHJlc3VsdC55KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc1tqXSA9IHNbaiAtIDFdO1xuICAgICAgICAgICAgaFtqXSA9IDAuMjUgKiBoW2ogLSAxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQueTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgRXN0aW1hdGUgd2hhdCBpcyB0aGUgbWF4aW11bSBwb2x5bm9taWFsIGV2YWx1YXRpb24gZXJyb3IgdmFsdWUgdW5kZXIgd2hpY2ggcG9seW5vbWlhbCBldmFsdWF0aW9uIGNvdWxkIGJlIGluIGZhY3QgMC5cbiAgICAgKlxuICAgICAqICBAcGFyYW0ge251bWJlcn0gbWF4QWJzWFxuICAgICAqICBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIHplcm9FcnJvckVzdGltYXRlKG1heEFic1gpIHtcbiAgICAgICAgY29uc3QgcG9seSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IEVSUkYgPSAxZS0xNTtcblxuICAgICAgICBpZiAodHlwZW9mIG1heEFic1ggPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJiID0gcG9seS5ib3VuZHMoKTtcblxuICAgICAgICAgICAgbWF4QWJzWCA9IE1hdGgubWF4KE1hdGguYWJzKHJiLm1pblgpLCBNYXRoLmFicyhyYi5tYXhYKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF4QWJzWCA8IDAuMDAxKSB7XG4gICAgICAgICAgICByZXR1cm4gMiAqIE1hdGguYWJzKHBvbHkuZXZhbChFUlJGKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuID0gcG9seS5jb2Vmcy5sZW5ndGggLSAxO1xuICAgICAgICBjb25zdCBhbiA9IHBvbHkuY29lZnNbbl07XG5cbiAgICAgICAgcmV0dXJuIDEwICogRVJSRiAqIHBvbHkuY29lZnMucmVkdWNlKChtLCB2LCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBubSA9IHYgLyBhbiAqIE1hdGgucG93KG1heEFic1gsIGkpO1xuICAgICAgICAgICAgcmV0dXJuIG5tID4gbSA/IG5tIDogbTtcbiAgICAgICAgfSwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIENhbGN1bGF0ZXMgdXBwZXIgUmVhbCByb290cyBib3VuZHMuIDxici8+XG4gICAgICogIFJlYWwgcm9vdHMgYXJlIGluIGludGVydmFsIFtuZWdYLCBwb3NYXS4gRGV0ZXJtaW5lZCBieSBGdWppd2FyYSBtZXRob2QuXG4gICAgICogIEBzZWUge0BsaW5rIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUHJvcGVydGllc19vZl9wb2x5bm9taWFsX3Jvb3RzfVxuICAgICAqXG4gICAgICogIEByZXR1cm5zIHt7IG5lZ1g6IG51bWJlciwgcG9zWDogbnVtYmVyIH19XG4gICAgICovXG4gICAgYm91bmRzVXBwZXJSZWFsRnVqaXdhcmEoKSB7XG4gICAgICAgIGxldCBhID0gdGhpcy5jb2VmcztcbiAgICAgICAgY29uc3QgbiA9IGEubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgYW4gPSBhW25dO1xuXG4gICAgICAgIGlmIChhbiAhPT0gMSkge1xuICAgICAgICAgICAgYSA9IHRoaXMuY29lZnMubWFwKHYgPT4gdiAvIGFuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGIgPSBhLm1hcCgodiwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChpIDwgbilcbiAgICAgICAgICAgICAgICA/IE1hdGgucG93KE1hdGguYWJzKChpID09PSAwKSA/IHYgLyAyIDogdiksIDEgLyAobiAtIGkpKVxuICAgICAgICAgICAgICAgIDogdjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IGNvZWZTZWxlY3Rpb25GdW5jO1xuICAgICAgICBjb25zdCBmaW5kMk1heCA9IGZ1bmN0aW9uKGFjYywgYmksIGkpIHtcbiAgICAgICAgICAgIGlmIChjb2VmU2VsZWN0aW9uRnVuYyhpKSkge1xuICAgICAgICAgICAgICAgIGlmIChhY2MubWF4IDwgYmkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjLm5lYXJtYXggPSBhY2MubWF4O1xuICAgICAgICAgICAgICAgICAgICBhY2MubWF4ID0gYmk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFjYy5uZWFybWF4IDwgYmkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjLm5lYXJtYXggPSBiaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvZWZTZWxlY3Rpb25GdW5jID0gZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgcmV0dXJuIGkgPCBuICYmIGFbaV0gPCAwO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL25vLWZuLXJlZmVyZW5jZS1pbi1pdGVyYXRvclxuICAgICAgICBjb25zdCBtYXhfbmVhcm1heF9wb3MgPSBiLnJlZHVjZShmaW5kMk1heCwge21heDogMCwgbmVhcm1heDogMH0pO1xuXG4gICAgICAgIGNvZWZTZWxlY3Rpb25GdW5jID0gZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgcmV0dXJuIGkgPCBuICYmICgobiAlIDIgPT09IGkgJSAyKSA/IGFbaV0gPCAwIDogYVtpXSA+IDApO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL25vLWZuLXJlZmVyZW5jZS1pbi1pdGVyYXRvclxuICAgICAgICBjb25zdCBtYXhfbmVhcm1heF9uZWcgPSBiLnJlZHVjZShmaW5kMk1heCwge21heDogMCwgbmVhcm1heDogMH0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZWdYOiAtMiAqIG1heF9uZWFybWF4X25lZy5tYXgsXG4gICAgICAgICAgICBwb3NYOiAyICogbWF4X25lYXJtYXhfcG9zLm1heFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBDYWxjdWxhdGVzIGxvd2VyIFJlYWwgcm9vdHMgYm91bmRzLiA8YnIvPlxuICAgICAqICBUaGVyZSBhcmUgbm8gUmVhbCByb290cyBpbiBpbnRlcnZhbCA8bmVnWCwgcG9zWD4uIERldGVybWluZWQgYnkgRnVqaXdhcmEgbWV0aG9kLlxuICAgICAqICBAc2VlIHtAbGluayBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Byb3BlcnRpZXNfb2ZfcG9seW5vbWlhbF9yb290c31cbiAgICAgKlxuICAgICAqICBAcmV0dXJucyB7eyBuZWdYOiBudW1iZXIsIHBvc1g6IG51bWJlciB9fVxuICAgICAqL1xuICAgIGJvdW5kc0xvd2VyUmVhbEZ1aml3YXJhKCkge1xuICAgICAgICBjb25zdCBwb2x5ID0gbmV3IFBvbHlub21pYWwoKTtcblxuICAgICAgICBwb2x5LmNvZWZzID0gdGhpcy5jb2Vmcy5zbGljZSgpLnJldmVyc2UoKTtcblxuICAgICAgICBjb25zdCByZXMgPSBwb2x5LmJvdW5kc1VwcGVyUmVhbEZ1aml3YXJhKCk7XG5cbiAgICAgICAgcmVzLm5lZ1ggPSAxIC8gcmVzLm5lZ1g7XG4gICAgICAgIHJlcy5wb3NYID0gMSAvIHJlcy5wb3NYO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIENhbGN1bGF0ZXMgbGVmdCBhbmQgcmlnaHQgUmVhbCByb290cyBib3VuZHMuIDxici8+XG4gICAgICogIFJlYWwgcm9vdHMgYXJlIGluIGludGVydmFsIFttaW5YLCBtYXhYXS4gQ29tYmluZXMgRnVqaXdhcmEgbG93ZXIgYW5kIHVwcGVyIGJvdW5kcyB0byBnZXQgbWluaW1hbCBpbnRlcnZhbC5cbiAgICAgKiAgQHNlZSB7QGxpbmsgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Qcm9wZXJ0aWVzX29mX3BvbHlub21pYWxfcm9vdHN9XG4gICAgICpcbiAgICAgKiAgQHJldHVybnMge3sgbWluWDogbnVtYmVyLCBtYXhYOiBudW1iZXIgfX1cbiAgICAqL1xuICAgIGJvdW5kcygpIHtcbiAgICAgICAgY29uc3QgdXJiID0gdGhpcy5ib3VuZHNVcHBlclJlYWxGdWppd2FyYSgpO1xuICAgICAgICBjb25zdCByYiA9IHttaW5YOiB1cmIubmVnWCwgbWF4WDogdXJiLnBvc1h9O1xuXG4gICAgICAgIGlmICh1cmIubmVnWCA9PT0gMCAmJiB1cmIucG9zWCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVyYi5uZWdYID09PSAwKSB7XG4gICAgICAgICAgICByYi5taW5YID0gdGhpcy5ib3VuZHNMb3dlclJlYWxGdWppd2FyYSgpLnBvc1g7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodXJiLnBvc1ggPT09IDApIHtcbiAgICAgICAgICAgIHJiLm1heFggPSB0aGlzLmJvdW5kc0xvd2VyUmVhbEZ1aml3YXJhKCkubmVnWDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyYi5taW5YID4gcmIubWF4WCkge1xuICAgICAgICAgICAgcmIubWluWCA9IHJiLm1heFggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJiO1xuICAgICAgICAvLyBUT0RPOiBpZiBzdXJlIHRoYXQgdGhlcmUgYXJlIG5vIGNvbXBsZXggcm9vdHNcbiAgICAgICAgLy8gKG1heWJlIGJ5IHVzaW5nIFN0dXJtJ3MgdGhlb3JlbSkgdXNlOlxuICAgICAgICAvLyByZXR1cm4gdGhpcy5ib3VuZHNSZWFsTGFndWVycmUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgQ2FsY3VsYXRlcyBhYnNvbHV0ZSB1cHBlciByb290cyBib3VuZC4gPGJyLz5cbiAgICAgKiAgQWxsIChDb21wbGV4IGFuZCBSZWFsKSByb290cyBtYWduaXR1ZGVzIGFyZSAmbHQ7PSByZXN1bHQuIERldGVybWluZWQgYnkgUm91Y2hlIG1ldGhvZC5cbiAgICAgKiAgQHNlZSB7QGxpbmsgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Qcm9wZXJ0aWVzX29mX3BvbHlub21pYWxfcm9vdHN9XG4gICAgICpcbiAgICAgKiAgQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBib3VuZFVwcGVyQWJzUm91Y2hlKCkge1xuICAgICAgICBjb25zdCBhID0gdGhpcy5jb2VmcztcbiAgICAgICAgY29uc3QgbiA9IGEubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgbWF4ID0gYS5yZWR1Y2UoKHByZXYsIGN1cnIsIGkpID0+IHtcbiAgICAgICAgICAgIGlmIChpICE9PSBuKSB7XG4gICAgICAgICAgICAgICAgY3VyciA9IE1hdGguYWJzKGN1cnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiAocHJldiA8IGN1cnIpID8gY3VyciA6IHByZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgfSwgMCk7XG5cbiAgICAgICAgcmV0dXJuIDEgKyBtYXggLyBNYXRoLmFicyhhW25dKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgQ2FsY3VsYXRlcyBhYnNvbHV0ZSBsb3dlciByb290cyBib3VuZC4gPGJyLz5cbiAgICAgKiAgQWxsIChDb21wbGV4IGFuZCBSZWFsKSByb290cyBtYWduaXR1ZGVzIGFyZSAmZ3Q7PSByZXN1bHQuIERldGVybWluZWQgYnkgUm91Y2hlIG1ldGhvZC5cbiAgICAgKiAgQHNlZSB7QGxpbmsgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Qcm9wZXJ0aWVzX29mX3BvbHlub21pYWxfcm9vdHN9XG4gICAgICpcbiAgICAgKiAgQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBib3VuZExvd2VyQWJzUm91Y2hlKCkge1xuICAgICAgICBjb25zdCBhID0gdGhpcy5jb2VmcztcbiAgICAgICAgY29uc3QgbWF4ID0gYS5yZWR1Y2UoKHByZXYsIGN1cnIsIGkpID0+IHtcbiAgICAgICAgICAgIGlmIChpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgY3VyciA9IE1hdGguYWJzKGN1cnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiAocHJldiA8IGN1cnIpID8gY3VyciA6IHByZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgfSwgMCk7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKGFbMF0pIC8gKE1hdGguYWJzKGFbMF0pICsgbWF4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgQ2FsY3VsYXRlcyBsZWZ0IGFuZCByaWdodCBSZWFsIHJvb3RzIGJvdW5kcy48YnIvPlxuICAgICAqICBXT1JLUyBPTkxZIGlmIGFsbCBwb2x5bm9taWFsIHJvb3RzIGFyZSBSZWFsLlxuICAgICAqICBSZWFsIHJvb3RzIGFyZSBpbiBpbnRlcnZhbCBbbWluWCwgbWF4WF0uIERldGVybWluZWQgYnkgTGFndWVycmUgbWV0aG9kLlxuICAgICAqICBAc2VlIHtAbGluayBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Byb3BlcnRpZXNfb2ZfcG9seW5vbWlhbF9yb290c31cbiAgICAgKlxuICAgICAqICBAcmV0dXJucyB7eyBtaW5YOiBudW1iZXIsIG1heFg6IG51bWJlciB9fVxuICAgICAqL1xuICAgIGJvdW5kc1JlYWxMYWd1ZXJyZSgpIHtcbiAgICAgICAgY29uc3QgYSA9IHRoaXMuY29lZnM7XG4gICAgICAgIGNvbnN0IG4gPSBhLmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IHAxID0gLWFbbiAtIDFdIC8gKG4gKiBhW25dKTtcbiAgICAgICAgY29uc3QgdW5kZXJzcXJ0ID0gYVtuIC0gMV0gKiBhW24gLSAxXSAtIDIgKiBuIC8gKG4gLSAxKSAqIGFbbl0gKiBhW24gLSAyXTtcbiAgICAgICAgbGV0IHAyID0gKG4gLSAxKSAvIChuICogYVtuXSkgKiBNYXRoLnNxcnQodW5kZXJzcXJ0KTtcblxuICAgICAgICBpZiAocDIgPCAwKSB7XG4gICAgICAgICAgICBwMiA9IC1wMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtaW5YOiBwMSAtIHAyLFxuICAgICAgICAgICAgbWF4WDogcDEgKyBwMlxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBSb290IGNvdW50IGJ5IERlc2NhcnRlcyBydWxlIG9mIHNpZ25zLiA8YnIvPlxuICAgICAqICBSZXR1cm5zIG1heGltdW0gbnVtYmVyIG9mIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSByZWFsIHJvb3RzIGFuZCBtaW5pbXVtIG51bWJlciBvZiBjb21wbGV4IHJvb3RzLlxuICAgICAqICBAc2VlIHtAbGluayBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Rlc2NhcnRlcyUyN19ydWxlX29mX3NpZ25zfVxuICAgICAqXG4gICAgICogIEByZXR1cm5zIHt7bWF4UmVhbFBvczogbnVtYmVyLCBtYXhSZWFsTmVnOiBudW1iZXIsIG1pbkNvbXBsZXg6IG51bWJlcn19XG4gICAgICovXG4gICAgY291bnRSb290c0Rlc2NhcnRlcygpIHtcbiAgICAgICAgY29uc3QgYSA9IHRoaXMuY29lZnM7XG4gICAgICAgIGNvbnN0IG4gPSBhLmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IGFjY3VtID0gYS5yZWR1Y2UoKGFjYywgYWksIGkpID0+IHtcbiAgICAgICAgICAgIGlmIChhY2MucHJldl9hICE9PSAwICYmIGFpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKChhY2MucHJldl9hIDwgMCkgPT09IChhaSA+IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjYy5wb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCgoaSAlIDIgPT09IDApICE9PSAoYWNjLnByZXZfYSA8IDApKSA9PT0gKChpICUgMiA9PT0gMSkgIT09IChhaSA+IDApKSkge1xuICAgICAgICAgICAgICAgICAgICBhY2MubmVnKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWNjLnByZXZfYSA9IGFpO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge3BvczogMCwgbmVnOiAwLCBwcmV2X2E6IDB9KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWF4UmVhbFBvczogYWNjdW0ucG9zLFxuICAgICAgICAgICAgbWF4UmVhbE5lZzogYWNjdW0ubmVnLFxuICAgICAgICAgICAgbWluQ29tcGxleDogbiAtIChhY2N1bS5wb3MgKyBhY2N1bS5uZWcpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZ2V0dGVycyBhbmQgc2V0dGVyc1xuXG4gICAgLyoqXG4gICAgICogIGdldCBkZWdyZWVcbiAgICAgKlxuICAgICAqICBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldERlZ3JlZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29lZnMubGVuZ3RoIC0gMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgZ2V0RGVyaXZhdGl2ZVxuICAgICAqXG4gICAgICogIEByZXR1cm5zIHttb2R1bGU6a2xkLXBvbHlub21pYWwuUG9seW5vbWlhbH1cbiAgICAgKi9cbiAgICBnZXREZXJpdmF0aXZlKCkge1xuICAgICAgICBjb25zdCBkZXJpdmF0aXZlID0gbmV3IFBvbHlub21pYWwoKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuY29lZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRlcml2YXRpdmUuY29lZnMucHVzaChpICogdGhpcy5jb2Vmc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVyaXZhdGl2ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgZ2V0Um9vdHNcbiAgICAgKlxuICAgICAqICBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICBnZXRSb290cygpIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcblxuICAgICAgICB0aGlzLnNpbXBsaWZ5RXF1YWxzKCk7XG5cbiAgICAgICAgc3dpdGNoICh0aGlzLmdldERlZ3JlZSgpKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJlc3VsdCA9IFtdOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTogcmVzdWx0ID0gdGhpcy5nZXRMaW5lYXJSb290KCk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOiByZXN1bHQgPSB0aGlzLmdldFF1YWRyYXRpY1Jvb3RzKCk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOiByZXN1bHQgPSB0aGlzLmdldEN1YmljUm9vdHMoKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6IHJlc3VsdCA9IHRoaXMuZ2V0UXVhcnRpY1Jvb3RzKCk7IGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIGdldFJvb3RzSW5JbnRlcnZhbFxuICAgICAqXG4gICAgICogIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAgICAgKiAgQHBhcmFtIHtudW1iZXJ9IG1heFxuICAgICAqICBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICBnZXRSb290c0luSW50ZXJ2YWwobWluLCBtYXgpIHtcbiAgICAgICAgY29uc3Qgcm9vdHMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gcHVzaCh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHJvb3RzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZ2V0RGVncmVlKCkgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVW5leHBlY3RlZCBlbXB0eSBwb2x5bm9taWFsXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZ2V0RGVncmVlKCkgPT09IDEpIHtcbiAgICAgICAgICAgIHB1c2godGhpcy5iaXNlY3Rpb24obWluLCBtYXgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGdldCByb290cyBvZiBkZXJpdmF0aXZlXG4gICAgICAgICAgICBjb25zdCBkZXJpdiA9IHRoaXMuZ2V0RGVyaXZhdGl2ZSgpO1xuICAgICAgICAgICAgY29uc3QgZHJvb3RzID0gZGVyaXYuZ2V0Um9vdHNJbkludGVydmFsKG1pbiwgbWF4KTtcblxuICAgICAgICAgICAgaWYgKGRyb290cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gZmluZCByb290IG9uIFttaW4sIGRyb290c1swXV1cbiAgICAgICAgICAgICAgICBwdXNoKHRoaXMuYmlzZWN0aW9uKG1pbiwgZHJvb3RzWzBdKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBmaW5kIHJvb3Qgb24gW2Ryb290c1tpXSxkcm9vdHNbaSsxXV0gZm9yIDAgPD0gaSA8PSBjb3VudC0yXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gZHJvb3RzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBwdXNoKHRoaXMuYmlzZWN0aW9uKGRyb290c1tpXSwgZHJvb3RzW2kgKyAxXSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGZpbmQgcm9vdCBvbiBbZHJvb3RzW2NvdW50LTFdLHhtYXhdXG4gICAgICAgICAgICAgICAgcHVzaCh0aGlzLmJpc2VjdGlvbihkcm9vdHNbZHJvb3RzLmxlbmd0aCAtIDFdLCBtYXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHBvbHlub21pYWwgaXMgbW9ub3RvbmUgb24gW21pbixtYXhdLCBoYXMgYXQgbW9zdCBvbmUgcm9vdFxuICAgICAgICAgICAgICAgIHB1c2godGhpcy5iaXNlY3Rpb24obWluLCBtYXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByb290cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgZ2V0TGluZWFyUm9vdFxuICAgICAqXG4gICAgICogIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0TGluZWFyUm9vdCgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGNvbnN0IGEgPSB0aGlzLmNvZWZzWzFdO1xuXG4gICAgICAgIGlmIChhICE9PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgtdGhpcy5jb2Vmc1swXSAvIGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgZ2V0UXVhZHJhdGljUm9vdHNcbiAgICAgKlxuICAgICAqICBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICBnZXRRdWFkcmF0aWNSb290cygpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgIGlmICh0aGlzLmdldERlZ3JlZSgpID09PSAyKSB7XG4gICAgICAgICAgICBjb25zdCBhID0gdGhpcy5jb2Vmc1syXTtcbiAgICAgICAgICAgIGNvbnN0IGIgPSB0aGlzLmNvZWZzWzFdIC8gYTtcbiAgICAgICAgICAgIGNvbnN0IGMgPSB0aGlzLmNvZWZzWzBdIC8gYTtcbiAgICAgICAgICAgIGNvbnN0IGQgPSBiICogYiAtIDQgKiBjO1xuXG4gICAgICAgICAgICBpZiAoZCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gTWF0aC5zcXJ0KGQpO1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKDAuNSAqICgtYiArIGUpKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goMC41ICogKC1iIC0gZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIHJlYWxseSB0d28gcm9vdHMgd2l0aCBzYW1lIHZhbHVlLCBidXQgd2Ugb25seSByZXR1cm4gb25lXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKDAuNSAqIC1iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVsc2UgaW1hZ2luYXJ5IHJlc3VsdHNcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBnZXRDdWJpY1Jvb3RzXG4gICAgICpcbiAgICAgKiAgVGhpcyBjb2RlIGlzIGJhc2VkIG9uIE1nY1BvbHlub21pYWwuY3BwIHdyaXR0ZW4gYnkgRGF2aWQgRWJlcmx5LiAgSGlzXG4gICAgICogIGNvZGUgYWxvbmcgd2l0aCBtYW55IG90aGVyIGV4Y2VsbGVudCBleGFtcGxlcyBhcmUgYXZhaWFibGUgYXQgaGlzIHNpdGU6XG4gICAgICogIGh0dHA6Ly93d3cuZ2VvbWV0cmljdG9vbHMuY29tXG4gICAgICpcbiAgICAgKiAgQHJldHVybnMge0FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgZ2V0Q3ViaWNSb290cygpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgIGlmICh0aGlzLmdldERlZ3JlZSgpID09PSAzKSB7XG4gICAgICAgICAgICBjb25zdCBjMyA9IHRoaXMuY29lZnNbM107XG4gICAgICAgICAgICBjb25zdCBjMiA9IHRoaXMuY29lZnNbMl0gLyBjMztcbiAgICAgICAgICAgIGNvbnN0IGMxID0gdGhpcy5jb2Vmc1sxXSAvIGMzO1xuICAgICAgICAgICAgY29uc3QgYzAgPSB0aGlzLmNvZWZzWzBdIC8gYzM7XG5cbiAgICAgICAgICAgIGNvbnN0IGEgPSAoMyAqIGMxIC0gYzIgKiBjMikgLyAzO1xuICAgICAgICAgICAgY29uc3QgYiA9ICgyICogYzIgKiBjMiAqIGMyIC0gOSAqIGMxICogYzIgKyAyNyAqIGMwKSAvIDI3O1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gYzIgLyAzO1xuICAgICAgICAgICAgbGV0IGRpc2NyaW0gPSBiICogYiAvIDQgKyBhICogYSAqIGEgLyAyNztcbiAgICAgICAgICAgIGNvbnN0IGhhbGZCID0gYiAvIDI7XG5cbiAgICAgICAgICAgIGNvbnN0IFpFUk9lcHNpbG9uID0gdGhpcy56ZXJvRXJyb3JFc3RpbWF0ZSgpO1xuXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZGlzY3JpbSkgPD0gWkVST2Vwc2lsb24pIHtcbiAgICAgICAgICAgICAgICBkaXNjcmltID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRpc2NyaW0gPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IE1hdGguc3FydChkaXNjcmltKTtcbiAgICAgICAgICAgICAgICBsZXQgcm9vdDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zaGFkb3dcblxuICAgICAgICAgICAgICAgIGxldCB0bXAgPSAtaGFsZkIgKyBlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRtcCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3QgPSBNYXRoLnBvdyh0bXAsIDEgLyAzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3QgPSAtTWF0aC5wb3coLXRtcCwgMSAvIDMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRtcCA9IC1oYWxmQiAtIGU7XG5cbiAgICAgICAgICAgICAgICBpZiAodG1wID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdCArPSBNYXRoLnBvdyh0bXAsIDEgLyAzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3QgLT0gTWF0aC5wb3coLXRtcCwgMSAvIDMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChyb290IC0gb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRpc2NyaW0gPCAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoLWEgLyAzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhbmdsZSA9IE1hdGguYXRhbjIoTWF0aC5zcXJ0KC1kaXNjcmltKSwgLWhhbGZCKSAvIDM7XG4gICAgICAgICAgICAgICAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzcXJ0MyA9IE1hdGguc3FydCgzKTtcblxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCgyICogZGlzdGFuY2UgKiBjb3MgLSBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCgtZGlzdGFuY2UgKiAoY29zICsgc3FydDMgKiBzaW4pIC0gb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goLWRpc3RhbmNlICogKGNvcyAtIHNxcnQzICogc2luKSAtIG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgdG1wO1xuXG4gICAgICAgICAgICAgICAgaWYgKGhhbGZCID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wID0gLU1hdGgucG93KGhhbGZCLCAxIC8gMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0bXAgPSBNYXRoLnBvdygtaGFsZkIsIDEgLyAzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goMiAqIHRtcCAtIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgLy8gcmVhbGx5IHNob3VsZCByZXR1cm4gbmV4dCByb290IHR3aWNlLCBidXQgd2UgcmV0dXJuIG9ubHkgb25lXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKC10bXAgLSBvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIENhbGN1bGF0ZXMgcm9vdHMgb2YgcXVhcnRpYyBwb2x5bm9taWFsLiA8YnIvPlxuICAgICAqICBGaXJzdCwgZGVyaXZhdGl2ZSByb290cyBhcmUgZm91bmQsIHRoZW4gdXNlZCB0byBzcGxpdCBxdWFydGljIHBvbHlub21pYWxcbiAgICAgKiAgaW50byBzZWdtZW50cywgZWFjaCBjb250YWluaW5nIG9uZSByb290IG9mIHF1YXJ0aWMgcG9seW5vbWlhbC5cbiAgICAgKiAgU2VnbWVudHMgYXJlIHRoZW4gcGFzc2VkIHRvIG5ld3RvbidzIG1ldGhvZCB0byBmaW5kIHJvb3RzLlxuICAgICAqXG4gICAgICogIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSByb290c1xuICAgICAqL1xuICAgIGdldFF1YXJ0aWNSb290cygpIHtcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuZ2V0RGVncmVlKCk7XG5cbiAgICAgICAgaWYgKG4gPT09IDQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvbHkgPSBuZXcgUG9seW5vbWlhbCgpO1xuXG4gICAgICAgICAgICBwb2x5LmNvZWZzID0gdGhpcy5jb2Vmcy5zbGljZSgpO1xuICAgICAgICAgICAgcG9seS5kaXZpZGVFcXVhbHNTY2FsYXIocG9seS5jb2Vmc1tuXSk7XG5cbiAgICAgICAgICAgIGNvbnN0IEVSUkYgPSAxZS0xNTtcblxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHBvbHkuY29lZnNbMF0pIDwgMTAgKiBFUlJGICogTWF0aC5hYnMocG9seS5jb2Vmc1szXSkpIHtcbiAgICAgICAgICAgICAgICBwb2x5LmNvZWZzWzBdID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcG9seV9kID0gcG9seS5nZXREZXJpdmF0aXZlKCk7XG4gICAgICAgICAgICBjb25zdCBkZXJydCA9IHBvbHlfZC5nZXRSb290cygpLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICAgICAgICAgIGNvbnN0IGRlcnkgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IG5yID0gZGVycnQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IHJiID0gdGhpcy5ib3VuZHMoKTtcblxuICAgICAgICAgICAgY29uc3QgbWF4YWJzWCA9IE1hdGgubWF4KE1hdGguYWJzKHJiLm1pblgpLCBNYXRoLmFicyhyYi5tYXhYKSk7XG4gICAgICAgICAgICBjb25zdCBaRVJPZXBzaWxvbiA9IHRoaXMuemVyb0Vycm9yRXN0aW1hdGUobWF4YWJzWCk7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG5yOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkZXJ5LnB1c2gocG9seS5ldmFsKGRlcnJ0W2ldKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG5yOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoZGVyeVtpXSkgPCBaRVJPZXBzaWxvbikge1xuICAgICAgICAgICAgICAgICAgICBkZXJ5W2ldID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGR4ID0gTWF0aC5tYXgoMC4xICogKHJiLm1heFggLSByYi5taW5YKSAvIG4sIEVSUkYpO1xuICAgICAgICAgICAgY29uc3QgZ3Vlc3NlcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgbWlubWF4ID0gW107XG5cbiAgICAgICAgICAgIGlmIChuciA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlcnlbMF0gIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZ24oZGVyeVswXSkgIT09IHNpZ24ocG9seS5ldmFsKGRlcnJ0WzBdIC0gZHgpIC0gZGVyeVswXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGd1ZXNzZXMucHVzaChkZXJydFswXSAtIGR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbm1heC5wdXNoKFtyYi5taW5YLCBkZXJydFswXV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZGVycnRbMF0sIGRlcnJ0WzBdKTtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbnI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVyeVtpICsgMV0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChkZXJydFtpICsgMV0sIGRlcnJ0W2kgKyAxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2lnbihkZXJ5W2ldKSAhPT0gc2lnbihkZXJ5W2kgKyAxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGd1ZXNzZXMucHVzaCgoZGVycnRbaV0gKyBkZXJydFtpICsgMV0pIC8gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5tYXgucHVzaChbZGVycnRbaV0sIGRlcnJ0W2kgKyAxXV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkZXJ5W25yXSAhPT0gMCAmJiBzaWduKGRlcnlbbnJdKSAhPT0gc2lnbihwb2x5LmV2YWwoZGVycnRbbnJdICsgZHgpIC0gZGVyeVtucl0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGd1ZXNzZXMucHVzaChkZXJydFtucl0gKyBkeCk7XG4gICAgICAgICAgICAgICAgICAgIG1pbm1heC5wdXNoKFtkZXJydFtucl0sIHJiLm1heFhdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICAgICAgICAgKiAgQHJldHVybnMge251bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgZiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9seS5ldmFsKHgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgICAgICAgICAqICBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBkZiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9seV9kLmV2YWwoeCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoZ3Vlc3Nlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGd1ZXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZ3Vlc3Nlc1tpXSA9IFBvbHlub21pYWwubmV3dG9uU2VjYW50QmlzZWN0aW9uKGd1ZXNzZXNbaV0sIGYsIGRmLCAzMiwgbWlubWF4W2ldWzBdLCBtaW5tYXhbaV1bMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KGd1ZXNzZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQb2x5bm9taWFsO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/kld-polynomial@0.3.0/node_modules/kld-polynomial/lib/Polynomial.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/kld-polynomial@0.3.0/node_modules/kld-polynomial/lib/SqrtPolynomial.js":
/*!*******************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/kld-polynomial@0.3.0/node_modules/kld-polynomial/lib/SqrtPolynomial.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Polynomial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Polynomial.js */ \"(ssr)/../../node_modules/.pnpm/kld-polynomial@0.3.0/node_modules/kld-polynomial/lib/Polynomial.js\");\n/**\n *  SqrtPolynomial.js\n *\n *  @module SqrtPolynomial\n *  @copyright 2002-2019 Kevin Lindsey\n */\n\n\n\n/**\n *  SqrtPolynomial\n *\n *  @deprecated\n *  @memberof module:kld-polynomial\n */\nclass SqrtPolynomial extends _Polynomial_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    /**\n     *  eval\n     *\n     *  @param {number} x\n     *  @returns {number}\n     */\n    eval(x) {\n        const TOLERANCE = 1e-7;\n\n        let result = super.eval(x);\n\n        // NOTE: May need to change the following.  I added these to capture\n        // some really small negative values that were being generated by one\n        // of my Bezier arcLength functions\n        if (Math.abs(result) < TOLERANCE) {\n            result = 0;\n        }\n\n        if (result < 0) {\n            throw new RangeError(\"Cannot take square root of negative number\");\n        }\n\n        return Math.sqrt(result);\n    }\n\n    /**\n     *  toString\n     *\n     *  @returns {string}\n     */\n    toString() {\n        const result = super.toString();\n\n        return \"sqrt(\" + result + \")\";\n    }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SqrtPolynomial);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2tsZC1wb2x5bm9taWFsQDAuMy4wL25vZGVfbW9kdWxlcy9rbGQtcG9seW5vbWlhbC9saWIvU3FydFBvbHlub21pYWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0RBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsY0FBYyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHJlcG9ncmFwaC93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2tsZC1wb2x5bm9taWFsQDAuMy4wL25vZGVfbW9kdWxlcy9rbGQtcG9seW5vbWlhbC9saWIvU3FydFBvbHlub21pYWwuanM/NzdjZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBTcXJ0UG9seW5vbWlhbC5qc1xuICpcbiAqICBAbW9kdWxlIFNxcnRQb2x5bm9taWFsXG4gKiAgQGNvcHlyaWdodCAyMDAyLTIwMTkgS2V2aW4gTGluZHNleVxuICovXG5cbmltcG9ydCBQb2x5bm9taWFsIGZyb20gXCIuL1BvbHlub21pYWwuanNcIjtcblxuLyoqXG4gKiAgU3FydFBvbHlub21pYWxcbiAqXG4gKiAgQGRlcHJlY2F0ZWRcbiAqICBAbWVtYmVyb2YgbW9kdWxlOmtsZC1wb2x5bm9taWFsXG4gKi9cbmNsYXNzIFNxcnRQb2x5bm9taWFsIGV4dGVuZHMgUG9seW5vbWlhbCB7XG4gICAgLyoqXG4gICAgICogIGV2YWxcbiAgICAgKlxuICAgICAqICBAcGFyYW0ge251bWJlcn0geFxuICAgICAqICBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGV2YWwoeCkge1xuICAgICAgICBjb25zdCBUT0xFUkFOQ0UgPSAxZS03O1xuXG4gICAgICAgIGxldCByZXN1bHQgPSBzdXBlci5ldmFsKHgpO1xuXG4gICAgICAgIC8vIE5PVEU6IE1heSBuZWVkIHRvIGNoYW5nZSB0aGUgZm9sbG93aW5nLiAgSSBhZGRlZCB0aGVzZSB0byBjYXB0dXJlXG4gICAgICAgIC8vIHNvbWUgcmVhbGx5IHNtYWxsIG5lZ2F0aXZlIHZhbHVlcyB0aGF0IHdlcmUgYmVpbmcgZ2VuZXJhdGVkIGJ5IG9uZVxuICAgICAgICAvLyBvZiBteSBCZXppZXIgYXJjTGVuZ3RoIGZ1bmN0aW9uc1xuICAgICAgICBpZiAoTWF0aC5hYnMocmVzdWx0KSA8IFRPTEVSQU5DRSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbm5vdCB0YWtlIHNxdWFyZSByb290IG9mIG5lZ2F0aXZlIG51bWJlclwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQocmVzdWx0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgdG9TdHJpbmdcbiAgICAgKlxuICAgICAqICBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci50b1N0cmluZygpO1xuXG4gICAgICAgIHJldHVybiBcInNxcnQoXCIgKyByZXN1bHQgKyBcIilcIjtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNxcnRQb2x5bm9taWFsO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/kld-polynomial@0.3.0/node_modules/kld-polynomial/lib/SqrtPolynomial.js\n");

/***/ })

};
;